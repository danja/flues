This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
docs/
  IMPLEMENTATION_STATUS.md
  PLAN.md
  requirements.md
public/
  icon.svg
  manifest.webmanifest
  sw.js
src/
  audio/
    modules/
      DelayLinesModule.js
      EnvelopeModule.js
      FeedbackModule.js
      FilterModule.js
      InterfaceModule.js
      ModulationModule.js
      ReverbModule.js
      SourcesModule.js
    pm-synth-worklet.js
    PMSynthEngine.js
    PMSynthProcessor.js
  ui/
    KeyboardController.js
    KnobController.js
    MidiController.js
    RotarySwitchController.js
    Visualizer.js
  utils/
    signalAnalysis.js
  constants.js
  main.js
test-results/
  .last-run.json
tests/
  unit/
    modules/
      DelayLinesModule.test.js
      EnvelopeModule.test.js
      FeedbackModule.test.js
      FilterModule.test.js
      InterfaceModule.test.js
      ModulationModule.test.js
      ReverbModule.test.js
      SourcesModule.test.js
    PMSynthEngine.signal.test.js
  utils/
    signal-analyzers.js
    signal-generators.js
    test-helpers.js
  app.spec.js
.gitignore
index.html
package.json
playwright.config.js
README.md
vite.config.js
vitest.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/IMPLEMENTATION_STATUS.md">
# Stove Implementation Status

## Completed Components

### Phase 1: Core Audio Modules âœ…
- [x] **SourcesModule.js** - DC, White Noise, and Sawtooth sources with independent level controls
- [x] **EnvelopeModule.js** - AR envelope with exponential time mapping
- [x] **DelayLinesModule.js** - Dual delay lines with tuning and ratio control
- [x] **FeedbackModule.js** - Three-way feedback mixer

### Phase 2: Signal Processing Modules âœ…
- [x] **InterfaceModule.js** - Eight interface types (Pluck, Hit, Reed, Flute, Brass, Bow, Bell, Drum)
- [x] **FilterModule.js** - State-variable filter with morphable LP/BP/HP response
- [x] **ModulationModule.js** - LFO with bipolar AM/FM control

### Phase 3: Engine Integration âœ…
- [x] **PMSynthEngine.js** - Main synthesis engine integrating all modules
- [x] **pm-synth-worklet.js** - AudioWorklet processor for real-time audio
- [x] **PMSynthProcessor.js** - Web Audio API interface with fallback support

### Phase 4: UI Components âœ…
- [x] **KnobController.js** - Enhanced with bipolar display mode
- [x] **RotarySwitchController.js** - 5-position rotary switch for interface selection
- [x] **main.js** - Application coordinator with all parameter mappings
- [x] **constants.js** - Centralized default values and configuration

### Phase 5: Documentation âœ…
- [x] **PLAN.md** - Complete implementation plan with technical specifications
- [x] **requirements.md** - Original requirements document
- [x] **IMPLEMENTATION_STATUS.md** - This file

## Architecture Overview

```
Keyboard (Gate + CV)
    â†“
Sources (DC, Noise, Tone) â†’ Envelope â†’ Interface â†’ Delay Lines â† Feedback
                                            â†“            â†“
                                        Filter â†â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                            â†“
                                        Output
                                            â†‘
                                    Modulation (LFO)
                                    (AM/FM control)
```

## Module Details

### Signal Flow
1. **Keyboard** generates gate (on/off) and CV (frequency)
2. **Sources** generate excitation: DC + Noise + Sawtooth
3. **Envelope** applies AR envelope to sources
4. **Interface** applies nonlinear processing (8 types)
5. **Delay Lines** create resonance (dual lines with ratio control)
6. **Feedback** mixes delay outputs back to input
7. **Filter** shapes final tone (morphable LP/BP/HP)
8. **Modulation** adds LFO-based AM or FM

### Interface Types
- **Pluck**: One-way damping with transient brightening
- **Hit**: Sine-fold waveshaping for percussive strikes
- **Reed**: Biased clarinet-style saturation
- **Flute**: Soft jet response with breath noise
- **Brass**: Asymmetric lip buzz
- **Bow**: Stick-slip friction with controllable grip
- **Bell**: Metallic partial generator
- **Drum**: Energy-accumulating membrane drive

### Parameter Count
- Sources: 3 parameters (DC, Noise, Tone levels)
- Envelope: 2 parameters (Attack, Release)
- Interface: 2 parameters (Type, Intensity)
- Delay Lines: 2 parameters (Tuning, Ratio)
- Feedback: 3 parameters (Delay1, Delay2, Filter feedback)
- Filter: 3 parameters (Frequency, Q, Shape)
- Modulation: 2 parameters (LFO Freq, Type/Level)

**Total: 17 parameters**

## File Structure

```
pm-synth/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ audio/
â”‚   â”‚   â”œâ”€â”€ modules/
â”‚   â”‚   â”‚   â”œâ”€â”€ SourcesModule.js          (73 lines)
â”‚   â”‚   â”‚   â”œâ”€â”€ EnvelopeModule.js         (85 lines)
â”‚   â”‚   â”‚   â”œâ”€â”€ InterfaceModule.js        (150 lines)
â”‚   â”‚   â”‚   â”œâ”€â”€ DelayLinesModule.js       (138 lines)
â”‚   â”‚   â”‚   â”œâ”€â”€ FeedbackModule.js         (45 lines)
â”‚   â”‚   â”‚   â”œâ”€â”€ FilterModule.js           (101 lines)
â”‚   â”‚   â”‚   â””â”€â”€ ModulationModule.js       (93 lines)
â”‚   â”‚   â”œâ”€â”€ PMSynthEngine.js              (152 lines)
â”‚   â”‚   â”œâ”€â”€ pm-synth-worklet.js           (195 lines)
â”‚   â”‚   â””â”€â”€ PMSynthProcessor.js           (188 lines)
â”‚   â”œâ”€â”€ ui/
â”‚   â”‚   â”œâ”€â”€ KnobController.js             (82 lines) âœ¨ Enhanced
â”‚   â”‚   â”œâ”€â”€ RotarySwitchController.js     (93 lines) ğŸ†• New
â”‚   â”‚   â”œâ”€â”€ KeyboardController.js         (130 lines) â™»ï¸ Reused
â”‚   â”‚   â””â”€â”€ Visualizer.js                 (65 lines) â™»ï¸ Reused
â”‚   â”œâ”€â”€ main.js                           (348 lines)
â”‚   â””â”€â”€ constants.js                      (57 lines)
â””â”€â”€ docs/
    â”œâ”€â”€ requirements.md                   (Original spec)
    â”œâ”€â”€ PLAN.md                           (Implementation plan)
    â””â”€â”€ IMPLEMENTATION_STATUS.md          (This file)
```

## Next Steps

### Testing (Pending)
- [ ] Unit tests for all modules (Vitest)
- [ ] Integration tests (Playwright)
- [ ] Performance profiling

### UI (Pending)
- [ ] Update index.html with all controls
- [ ] Add CSS styling for new controls
- [ ] Implement responsive layout

### Documentation (Pending)
- [ ] Update README.md with full documentation
- [ ] Create architecture diagram (Mermaid)
- [ ] Add usage examples

### Deployment (Pending)
- [ ] Update build scripts
- [ ] Test in all browsers
- [ ] Deploy to GitHub Pages

## Testing the Implementation

To test the current implementation:

```bash
cd experiments/pm-synth
npm install
npm run dev
```

The synth should be accessible at http://localhost:5173

## Known Limitations

1. **HTML/CSS**: UI HTML needs to be created/updated to match new architecture
2. **Testing**: No tests written yet
3. **Documentation**: README needs updating
4. **Browser Testing**: Only tested in Chrome/Firefox so far

## Performance Targets

- âœ… Modular architecture (all modules < 200 lines)
- âœ… Pre-allocated buffers (no heap allocation in process())
- â³ CPU usage target: < 15% (to be measured)
- â³ Latency target: < 10ms with AudioWorklet (to be measured)

## Browser Compatibility

Expected compatibility:
- Chrome/Edge 66+ âœ…
- Firefox 76+ âœ…
- Safari 14.1+ â³
- iOS Safari 14.5+ â³

## Design Principles Achieved

- âœ… Small, focused classes (< 200 lines each)
- âœ… Consistent module API pattern
- âœ… Constants-driven configuration
- âœ… Clear signal flow
- âœ… Reusable UI components
- âœ… AudioWorklet with ScriptProcessor fallback

## Conclusion

The core Stove implementation is **complete and ready for testing**. All audio modules, engine integration, and UI components are implemented. Remaining work focuses on:
1. Creating/updating HTML interface
2. Writing comprehensive tests
3. Documentation and deployment

The architecture successfully achieves the goal of creating a modular, extensible physical modeling synthesizer that goes beyond the original clarinet-only implementation.
</file>

<file path="docs/PLAN.md">
# Physical Modelling Synth Implementation Plan

## Overview
Transform the pm-synth from a clarinet-specific synth into a general-purpose physical modeling synthesizer with modular architecture supporting multiple instrument types (pluck, hit, reed, flute, brass) and enhanced control capabilities.

## Architecture Transformation

### Core Signal Flow
```
Sources â†’ Envelope â†’ Interface â†’ Delay Lines â†’ Feedback â†’ Filter â†’ Output
   â†“                                                â†‘
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Modulation (LFO) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Module Breakdown

#### 1. **Sources Module** (NEW)
Create `src/audio/modules/SourcesModule.js`:
- Three independent sources: DC, White Noise, Sawtooth (pitch-tracking)
- Each with independent level control
- Summing mixer output
- CV input for sawtooth frequency

#### 2. **Envelope Module** (REFACTOR existing)
Refactor into `src/audio/modules/EnvelopeModule.js`:
- Gate-triggered AR envelope (Attack/Release only)
- Remove Decay/Sustain (per requirements)
- Applies to summed source signal

#### 3. **Interface Module** (NEW - replaces reed-only nonlinearity)
Create `src/audio/modules/InterfaceModule.js`:
- Rotary switch for 8 interface types
- Intensity parameter (0-1) controlling effect strength
- **Pluck**: Initial impulse with quick decay (Karplus-Strong style)
- **Hit**: Sharp impulse with variable hardness
- **Reed**: Clarinet-style nonlinear reflection (existing tanh)
- **Flute**: Edge tone simulation (softer nonlinearity)
- **Brass**: Lip model (asymmetric nonlinearity)
- **Bow**: Stick-slip friction model for sustained bows
- **Bell**: Metallic partial shaper for chime-like strikes
- **Drum**: Energy-accumulating membrane drive

#### 4. **Delay Lines Module** (REFACTOR existing)
Refactor into `src/audio/modules/DelayLinesModule.js`:
- Two independent delay lines with fractional interpolation
- CV-controlled length (pitch tracking)
- **Tuning** control: coarse pitch adjustment
- **Ratio** control: delay2_length = delay1_length Ã— ratio
  - Ratio = 1.0 (12 o'clock): equal lengths (harmonic)
  - Ratio < 1.0: inharmonic (drum/gong tones)
  - Ratio > 1.0: stretched inharmonic

#### 5. **Feedback Module** (NEW)
Create `src/audio/modules/FeedbackModule.js`:
- Three feedback paths with independent level controls:
  - Delay Line 1 output â†’ input
  - Delay Line 2 output â†’ input
  - Post-filter output â†’ input
- Summing junction before delay line inputs

#### 6. **Filter Module** (REFACTOR existing)
Refactor into `src/audio/modules/FilterModule.js`:
- **Frequency**: cutoff/center frequency
- **Q**: resonance/bandwidth
- **Shape**: morphing control (0-1)
  - 0.0: Lowpass
  - 0.5: Bandpass
  - 1.0: Highpass
- Use state-variable filter or parallel filter mix

#### 7. **Modulation Module** (NEW)
Create `src/audio/modules/ModulationModule.js`:
- Sine wave LFO with frequency control
- **Type/Level** control (bipolar):
  - Center (12 o'clock): No modulation
  - CCW (0-50): AM (amplitude modulation) 0-100%
  - CW (50-100): FM (frequency modulation) 0-100%
- Modulation targets: delay line length (FM) or output amplitude (AM)

## UI Implementation

### Control Layout
Create modular UI blocks in `src/ui/`:

1. **SourcesPanel.js**: 3 knobs (DC level, Noise level, Tone level)
2. **EnvelopePanel.js**: 2 knobs (Attack, Release)
3. **InterfacePanel.js**: 1 rotary switch, 1 knob (Type, Intensity)
4. **DelayLinesPanel.js**: 2 knobs (Tuning, Ratio)
5. **FeedbackPanel.js**: 3 knobs (Delay1 FB, Delay2 FB, Post-Filter FB)
6. **FilterPanel.js**: 3 knobs (Frequency, Q, Shape)
7. **ModulationPanel.js**: 2 knobs (LFO Freq, Type/Level)
8. **KeyboardController.js**: Reuse existing (provides Gate + CV)
9. **Visualizer.js**: Reuse existing

### New UI Components
- **RotarySwitchController.js**: 8-position switch for Interface type selection
- Update **KnobController.js**: Add bipolar mode for Modulation Type/Level

## Testing Strategy

### Unit Tests (Vitest)
- `tests/unit/modules/SourcesModule.test.js`
- `tests/unit/modules/EnvelopeModule.test.js`
- `tests/unit/modules/InterfaceModule.test.js`
- `tests/unit/modules/DelayLinesModule.test.js`
- `tests/unit/modules/FeedbackModule.test.js`
- `tests/unit/modules/FilterModule.test.js`
- `tests/unit/modules/ModulationModule.test.js`

### Integration Tests (Playwright)
- `tests/integration/pm-synth.spec.js`: Full signal chain tests
- UI interaction tests
- Audio output validation

## File Structure
```
pm-synth/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ audio/
â”‚   â”‚   â”œâ”€â”€ modules/
â”‚   â”‚   â”‚   â”œâ”€â”€ SourcesModule.js
â”‚   â”‚   â”‚   â”œâ”€â”€ EnvelopeModule.js
â”‚   â”‚   â”‚   â”œâ”€â”€ InterfaceModule.js
â”‚   â”‚   â”‚   â”œâ”€â”€ DelayLinesModule.js
â”‚   â”‚   â”‚   â”œâ”€â”€ FeedbackModule.js
â”‚   â”‚   â”‚   â”œâ”€â”€ FilterModule.js
â”‚   â”‚   â”‚   â””â”€â”€ ModulationModule.js
â”‚   â”‚   â”œâ”€â”€ PMSynthEngine.js (refactored from ClarinetEngine)
â”‚   â”‚   â”œâ”€â”€ pm-synth-worklet.js (refactored from clarinet-worklet)
â”‚   â”‚   â””â”€â”€ PMSynthProcessor.js (refactored from ClarinetProcessor)
â”‚   â”œâ”€â”€ ui/
â”‚   â”‚   â”œâ”€â”€ panels/
â”‚   â”‚   â”‚   â”œâ”€â”€ SourcesPanel.js
â”‚   â”‚   â”‚   â”œâ”€â”€ EnvelopePanel.js
â”‚   â”‚   â”‚   â”œâ”€â”€ InterfacePanel.js
â”‚   â”‚   â”‚   â”œâ”€â”€ DelayLinesPanel.js
â”‚   â”‚   â”‚   â”œâ”€â”€ FeedbackPanel.js
â”‚   â”‚   â”‚   â”œâ”€â”€ FilterPanel.js
â”‚   â”‚   â”‚   â””â”€â”€ ModulationPanel.js
â”‚   â”‚   â”œâ”€â”€ KnobController.js (enhanced)
â”‚   â”‚   â”œâ”€â”€ RotarySwitchController.js (new)
â”‚   â”‚   â”œâ”€â”€ KeyboardController.js (reuse)
â”‚   â”‚   â””â”€â”€ Visualizer.js (reuse)
â”‚   â”œâ”€â”€ main.js (refactored)
â”‚   â””â”€â”€ constants.js (expanded)
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/modules/
â”‚   â””â”€â”€ integration/
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ requirements.md (existing)
â”‚   â”œâ”€â”€ PLAN.md (this document)
â”‚   â””â”€â”€ architecture.mmd (update)
â””â”€â”€ index.html (updated layout)
```

## Implementation Phases

### Phase 1: Core Audio Modules (Foundation)
1. Create SourcesModule.js
2. Refactor EnvelopeModule.js (extract from existing)
3. Create DelayLinesModule.js (dual delay lines)
4. Create FeedbackModule.js
5. Create constants for all new parameters

### Phase 2: Signal Processing
1. Create InterfaceModule.js (5 types)
2. Refactor FilterModule.js (shape morphing)
3. Create ModulationModule.js (LFO)

### Phase 3: Engine Integration
1. Refactor PMSynthEngine.js to use all modules
2. Update pm-synth-worklet.js
3. Update PMSynthProcessor.js

### Phase 4: UI Implementation
1. Create RotarySwitchController.js
2. Enhance KnobController.js (bipolar mode)
3. Create all panel components
4. Update main.js for new architecture
5. Update index.html layout

### Phase 5: Testing & Documentation
1. Write unit tests for all modules
2. Write integration tests
3. Update architecture diagram
4. Write comprehensive README
5. Test all interface types and parameter ranges

## Key Design Principles

1. **Small, focused classes**: Each module < 200 lines
2. **Test-driven**: Unit test each module independently
3. **Reusable components**: UI controllers work for any parameter
4. **Clear signal flow**: Audio path is traceable through modules
5. **Consistent API**: All modules follow same initialization/process pattern
6. **Constants-driven**: All magic numbers in constants.js
7. **PWA-ready**: Responsive design, works offline

## Technical Details

### Module API Pattern
All audio modules follow this consistent interface:

```javascript
class ModuleName {
  constructor(sampleRate) {
    // Initialize state variables
  }

  setParameter(name, value) {
    // Update parameter (0-1 normalized)
  }

  process(input, cv, gate) {
    // Process one sample
    return output;
  }

  reset() {
    // Reset state (on note-on)
  }
}
```

### Signal Flow Details

1. **Keyboard** generates:
   - `gate`: 0 or 1 (note on/off)
   - `cv`: frequency in Hz

2. **Sources** generates excitation:
   - DC: constant value Ã— level
   - Noise: white noise Ã— level
   - Tone: naive_sawtooth(cv) Ã— level
   - Output: sum of all three

3. **Envelope** shapes sources:
   - AR envelope triggered by gate
   - Output: source Ã— envelope

4. **Interface** applies nonlinearity:
   - Type-dependent transfer function
   - Intensity controls effect strength
   - Output: processed signal

5. **Delay Lines** create resonance:
   - Two parallel delay lines
   - Length from CV + tuning offset
   - Ratio adjusts delay2 relative to delay1
   - Outputs: [delay1_out, delay2_out]

6. **Feedback** mixes signals:
   - Input = interface_out + delay1_fb + delay2_fb + filter_fb
   - Three independent gains
   - Output: mixed signal â†’ delay lines

7. **Filter** shapes tone:
   - SVF with morphable response
   - Shape blends LP/BP/HP
   - Q controls resonance
   - Output: filtered signal

8. **Modulation** adds movement:
   - LFO generates sine wave
   - Bipolar control selects AM or FM
   - AM: modulates output gain
   - FM: modulates delay line length

## Interface Type Implementations

- **Pluck**: Track the largest recent excursion, bleed energy on the return stroke, and introduce a brightness impulse from the input derivative for extra snap.
- **Hit**: Apply intensity-dependent sine foldover (multiple harmonics) followed by dynamic exponentiation to control hardness.
- **Reed**: Bias the input, drive a fast tanh, and scale the result to simulate reed stiffness; higher intensity adds more bite.
- **Flute**: Blend the input with controllable breath noise and a soft cubic shaper to replicate air jet instability.
- **Brass**: Use asymmetric drive (stronger on positive half cycles) with an additional bias to mimic lip buzz and growl.
- **Bow**: Implement stick-slip friction by integrating bow state, applying high-gain tanh to the slip velocity, and sprinkling light granular noise.
- **Bell**: Layer multiple harmonic sinusoids with a drifting phase and saturate the mix for shimmering, metallic partials.
- **Drum**: Accumulate absolute energy into a decaying reservoir, add per-hit noise, and combine with a saturated base waveform for membrane punch.

## State-Variable Filter Implementation

For morphable LP/BP/HP response:

```javascript
class SVFilter {
  process(input, freq, q, shape) {
    const f = 2 * Math.sin(Math.PI * freq / sampleRate);
    const qInv = 1 / q;

    // State-variable filter topology
    this.low += f * this.band;
    this.high = input - this.low - qInv * this.band;
    this.band += f * this.high;

    // Morph between responses
    if (shape < 0.5) {
      // Blend lowpass â†’ bandpass
      const mix = shape * 2;
      return this.low * (1 - mix) + this.band * mix;
    } else {
      // Blend bandpass â†’ highpass
      const mix = (shape - 0.5) * 2;
      return this.band * (1 - mix) + this.high * mix;
    }
  }
}
```

## Parameter Ranges and Mappings

### Sources
- DC Level: 0-1 linear
- Noise Level: 0-1 linear
- Tone Level: 0-1 linear

### Envelope
- Attack: 0.001-0.5s (exponential mapping)
- Release: 0.01-2.0s (exponential mapping)

### Interface
- Type: [Pluck, Hit, Reed, Flute, Brass]
- Intensity: 0-1 linear

### Delay Lines
- Tuning: -12 to +12 semitones (linear)
- Ratio: 0.5-2.0 (exponential, center = 1.0)

### Feedback
- Delay1 FB: 0-0.99 linear
- Delay2 FB: 0-0.99 linear
- Filter FB: 0-0.99 linear

### Filter
- Frequency: 20-20000 Hz (exponential)
- Q: 0.5-20 (exponential)
- Shape: 0-1 linear (0=LP, 0.5=BP, 1=HP)

### Modulation
- LFO Freq: 0.1-20 Hz (exponential)
- Type/Level: bipolar 0-100
  - 0-50: AM depth 100%-0%
  - 50: No modulation
  - 50-100: FM depth 0%-100%

## Performance Considerations

- Target: < 15% CPU usage on modern hardware
- AudioWorklet ensures < 10ms latency
- Dual delay lines: max length = sampleRate/20 (20 Hz lowest note)
- Memory footprint: ~2-3 MB (2x delay buffers)
- No heap allocations in process() functions
- All arrays pre-allocated in constructors

## Browser Compatibility

- Chrome/Edge 66+: Full AudioWorklet support
- Firefox 76+: Full AudioWorklet support
- Safari 14.1+: Full AudioWorklet support
- iOS Safari 14.5+: Requires user interaction for audio

## References

- Smith, J.O. "Physical Modeling Using Digital Waveguides" (1992)
- Karjalainen, M. "Plucked-string models: From Karplus-Strong to digital waveguides" (1998)
- VÃ¤limÃ¤ki, V. "Discrete-time modeling of acoustic tubes" (1995)
- Cook, P. "Real Sound Synthesis for Interactive Applications" (2002)
- Roads, C. "The Computer Music Tutorial" (1996)
</file>

<file path="docs/requirements.md">
# Physical Modelling Synth

Stove is an extended, general-purpose version of clarinet synth. It is built as a responsive PWA using Vite. Its user interface has a set of knobs in blocks corresponding to internal modules and a one-octave piano keyboard with computer keypresses mapped to GUI keys.

Code will be under experiments/pm-synth/src with a live app version built then copied into the www directory using Github actions.

The architecture is modular with blocks of the user interface mirroring code modules. Functionality is achieved in small classes, no large code files. All components have corresponding unit and integration tests using Vitest and Playwright.  

Signals are triggered by a gate and CV from the keyboard. The flow is from Sources through Envelope through Delay Lines. The Feedback module follows the Delay Lines passing signal back. Finally the Filter module gives tone control of the output.

## Modules

### Sources

Three sources are provided, each with a level control. They are DC - which corresponds to a constant pressure such as windspeed in a blown instrument; white noise to simulate turbulence; tone, which is a sawtooth wave with its frequency controlled by the CV.

### Envelope

The envelope section has two controls : Attack and Release controlling the initial rise in amplitude of the sources and the final decline. When a key is held done the signal is held constant.

### Interfaces

The interface module has a rotary switch for the type of stimulation and a knob for the intensity of the interface effect (such as reed stiffness).

* Pluck - simulating a guitar string pluck
* Hit - simulating a piano mallet or drum beater
* Reed - simulating a clarinet reed
* Flute - simulating a flute mouthpiece 
* Brass - simulating a trumpet mouthpiece

### Delay Lines

There are two delay lines with their length determined by the CV level, ie. pitch. When equal lengths these model the tube in a wind instrument or the string in a string instrument. This module has two controls, one for tuning (affecting the delay length) and one to adjust the ratio of the delay line lengths to simulate drum and gong sounds.

### Filter

The filter has three controls : Frequency, Q and Shape. The Shape controls the response from lowpass through bandpass to highpass.

### Modulation

This section has two knobs, one for LFO frequency and the other for type/level. The LFO is a sine wave. The Level knob applies zero modulation in the 12 o'clock position, maximum AM in the fully CCW position and maximum FM in the fully CW position.

### Feedback

This has three knobs controlling the level of feedback from the first and second delay line as well as post-Filter.
</file>

<file path="public/icon.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
  <defs>
    <radialGradient id="glow" cx="50%" cy="50%" r="60%">
      <stop offset="0%" stop-color="#4a9eff" stop-opacity="1" />
      <stop offset="65%" stop-color="#2855ff" stop-opacity="0.95" />
      <stop offset="100%" stop-color="#101622" stop-opacity="1" />
    </radialGradient>
  </defs>
  <rect width="512" height="512" rx="128" fill="#0c1020" />
  <circle cx="256" cy="256" r="210" fill="url(#glow)" />
  <path d="M256 122c-9.9 0-18 8.1-18 18v152c0 9.9 8.1 18 18 18s18-8.1 18-18V140c0-9.9-8.1-18-18-18zm0 216c-19.9 0-36 16.1-36 36s16.1 36 36 36 36-16.1 36-36-16.1-36-36-36z" fill="#ffffff"/>
</svg>
</file>

<file path="public/manifest.webmanifest">
{
  "name": "Stove",
  "short_name": "Stove",
  "description": "Modular physical modelling synthesizer",
  "start_url": ".",
  "display": "standalone",
  "background_color": "#0c1020",
  "theme_color": "#4a9eff",
  "icons": [
    {
      "src": "icon.svg",
      "sizes": "512x512",
      "type": "image/svg+xml",
      "purpose": "any"
    },
    {
      "src": "icon.svg",
      "sizes": "512x512",
      "type": "image/svg+xml",
      "purpose": "maskable"
    }
  ]
}
</file>

<file path="public/sw.js">
const CACHE_NAME = 'pm-synth-cache-v1';
const ASSETS = [
  './',
  './index.html',
  './manifest.webmanifest'
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => cache.addAll(ASSETS))
  );
});

self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((keys) =>
      Promise.all(keys.filter((k) => k !== CACHE_NAME).map((k) => caches.delete(k)))
    )
  );
});

self.addEventListener('fetch', (event) => {
  const { request } = event;
  if (request.method !== 'GET') return;

  event.respondWith(
    caches.match(request).then((cached) => {
      if (cached) {
        event.waitUntil(
          fetch(request).then((response) => {
            if (response && response.status === 200) {
              const clone = response.clone();
              caches.open(CACHE_NAME).then((cache) => cache.put(request, clone));
            }
          }).catch(() => {})
        );
        return cached;
      }

      return fetch(request)
        .then((response) => {
          if (!response || response.status !== 200 || response.type === 'opaque') {
            return response;
          }
          const clone = response.clone();
          caches.open(CACHE_NAME).then((cache) => cache.put(request, clone));
          return response;
        })
        .catch(() => cached);
    })
  );
});
</file>

<file path="src/audio/modules/DelayLinesModule.js">
// DelayLinesModule.js
// Dual delay lines with tuning and ratio control

export class DelayLinesModule {
    constructor(sampleRate = 44100) {
        this.sampleRate = sampleRate;

        // Maximum delay length (for lowest note ~20Hz)
        this.maxDelayLength = Math.floor(sampleRate / 20);

        // Delay lines
        this.delayLine1 = new Float32Array(this.maxDelayLength);
        this.delayLine2 = new Float32Array(this.maxDelayLength);

        // Write positions
        this.writePos1 = 0;
        this.writePos2 = 0;

        // Parameters
        this.tuningSemitones = 0;  // -12 to +12 semitones
        this.ratio = 1.0;           // 0.5 to 2.0 (delay2/delay1 ratio)

        // Current delay lengths
        this.delayLength1 = 1000;
        this.delayLength2 = 1000;

        // Current frequency
        this.frequency = 440;
    }

    /**
     * Set tuning offset in semitones
     * @param {number} value - Normalized 0-1, maps to -12 to +12 semitones
     */
    setTuning(value) {
        this.tuningSemitones = (value - 0.5) * 24; // -12 to +12
        if (this.frequency) {
            this.updateDelayLengths(this.frequency);
        }
    }

    /**
     * Set delay line ratio
     * @param {number} value - Normalized 0-1, maps to 0.5-2.0 (exponential)
     */
    setRatio(value) {
        // Exponential mapping, center (0.5) = 1.0
        if (value < 0.5) {
            // 0.0 -> 0.5, maps to 0.5 -> 1.0
            this.ratio = 0.5 + value;
        } else {
            // 0.5 -> 1.0, maps to 1.0 -> 2.0
            this.ratio = 1.0 + (value - 0.5) * 2;
        }
        if (this.frequency) {
            this.updateDelayLengths(this.frequency);
        }
    }

    /**
     * Update delay lengths based on CV and tuning
     * @param {number} cv - Control voltage (frequency in Hz)
     */
    updateDelayLengths(cv) {
        this.frequency = cv;

        // Apply tuning offset
        const tuningFactor = Math.pow(2, this.tuningSemitones / 12);
        const tunedFrequency = cv * tuningFactor;

        // Calculate delay line 1 length
        this.delayLength1 = Math.max(2, Math.min(
            this.sampleRate / tunedFrequency,
            this.maxDelayLength - 1
        ));

        // Calculate delay line 2 length with ratio
        this.delayLength2 = Math.max(2, Math.min(
            this.delayLength1 * this.ratio,
            this.maxDelayLength - 1
        ));
    }

    /**
     * Process one sample through both delay lines
     * @param {number} input - Input sample
     * @param {number} cv - Control voltage (frequency in Hz)
     * @returns {Object} {delay1: number, delay2: number}
     */
    process(input, cv) {
        // Update delay lengths if frequency changed
        if (cv !== this.frequency) {
            this.updateDelayLengths(cv);
        }

        // Read from delay line 1 with linear interpolation
        const readPos1Float = this.writePos1 - this.delayLength1;
        const readPos1Wrapped = (readPos1Float + this.maxDelayLength) % this.maxDelayLength;
        const readPos1Int = Math.floor(readPos1Wrapped);
        const readPos1Frac = readPos1Wrapped - readPos1Int;
        const nextPos1 = (readPos1Int + 1) % this.maxDelayLength;

        const output1 = this.delayLine1[readPos1Int] * (1 - readPos1Frac) +
            this.delayLine1[nextPos1] * readPos1Frac;

        // Read from delay line 2 with linear interpolation
        const readPos2Float = this.writePos2 - this.delayLength2;
        const readPos2Wrapped = (readPos2Float + this.maxDelayLength) % this.maxDelayLength;
        const readPos2Int = Math.floor(readPos2Wrapped);
        const readPos2Frac = readPos2Wrapped - readPos2Int;
        const nextPos2 = (readPos2Int + 1) % this.maxDelayLength;

        const output2 = this.delayLine2[readPos2Int] * (1 - readPos2Frac) +
            this.delayLine2[nextPos2] * readPos2Frac;

        // Write input to both delay lines
        this.delayLine1[this.writePos1] = input;
        this.delayLine2[this.writePos2] = input;

        // Advance write positions
        this.writePos1 = (this.writePos1 + 1) % this.maxDelayLength;
        this.writePos2 = (this.writePos2 + 1) % this.maxDelayLength;

        return { delay1: output1, delay2: output2 };
    }

    /**
     * Reset state (called on note-on)
     */
    reset() {
        this.delayLine1.fill(0);
        this.delayLine2.fill(0);
        this.writePos1 = 0;
        this.writePos2 = 0;

        // Add small initial excitation
        for (let i = 0; i < Math.min(100, this.maxDelayLength); i++) {
            this.delayLine1[i] = (Math.random() * 2 - 1) * 0.01;
            this.delayLine2[i] = (Math.random() * 2 - 1) * 0.01;
        }
    }
}
</file>

<file path="src/audio/modules/EnvelopeModule.js">
// EnvelopeModule.js
// Attack-Release envelope generator

export class EnvelopeModule {
    constructor(sampleRate = 44100) {
        this.sampleRate = sampleRate;

        // Envelope parameters (in seconds)
        this.attackTime = 0.01;   // 10ms default
        this.releaseTime = 0.05;  // 50ms default

        // State
        this.envelope = 0;
        this.gate = false;
        this.isActive = false;
    }

    /**
     * Set attack time
     * @param {number} value - Normalized 0-1, maps to 0.001-1.0s
     */
    setAttack(value) {
        // Exponential mapping: 0 = 0.001s (instant), 0.5 = 0.1s, 1.0 = 1.0s
        // Using formula: time = min * (max/min)^value
        const minTime = 0.001;  // 1ms
        const maxTime = 1.0;    // 1000ms
        this.attackTime = minTime * Math.pow(maxTime / minTime, value);
    }

    /**
     * Set release time
     * @param {number} value - Normalized 0-1, maps to 0.01-3.0s
     */
    setRelease(value) {
        // Exponential mapping: 0 = 0.01s (fast), 0.5 = 0.17s, 1.0 = 3.0s
        // Using formula: time = min * (max/min)^value
        const minTime = 0.01;   // 10ms
        const maxTime = 3.0;    // 3000ms
        this.releaseTime = minTime * Math.pow(maxTime / minTime, value);
    }

    /**
     * Trigger the envelope
     * @param {boolean} gateState - True for note-on, false for note-off
     */
    setGate(gateState) {
        this.gate = gateState;
        if (gateState) {
            this.isActive = true;
        }
    }

    /**
     * Process one sample
     * @returns {number} Current envelope value (0-1)
     */
    process() {
        if (this.gate) {
            // Attack phase
            const attackRate = 1.0 / (this.attackTime * this.sampleRate);
            this.envelope += attackRate;
            if (this.envelope > 1.0) {
                this.envelope = 1.0;
            }
        } else {
            // Release phase
            const releaseRate = 1.0 / (this.releaseTime * this.sampleRate);
            this.envelope -= releaseRate;
            if (this.envelope < 0) {
                this.envelope = 0;
                this.isActive = false;
            }
        }

        return this.envelope;
    }

    /**
     * Check if envelope is active
     * @returns {boolean} True if envelope is generating signal
     */
    isPlaying() {
        return this.isActive;
    }

    /**
     * Reset state (called on note-on)
     */
    reset() {
        this.envelope = 0;
        this.isActive = true;
    }
}
</file>

<file path="src/audio/modules/FeedbackModule.js">
// FeedbackModule.js
// Three-way feedback mixer with independent gains

export class FeedbackModule {
    constructor() {
        // Feedback gains (0-0.99 to prevent runaway)
        this.delay1Gain = 0.95;
        this.delay2Gain = 0.95;
        this.filterGain = 0.0;
    }

    /**
     * Set delay line 1 feedback gain
     * @param {number} value - Normalized 0-1, maps to 0-0.99
     */
    setDelay1Gain(value) {
        this.delay1Gain = value * 0.99;
    }

    /**
     * Set delay line 2 feedback gain
     * @param {number} value - Normalized 0-1, maps to 0-0.99
     */
    setDelay2Gain(value) {
        this.delay2Gain = value * 0.99;
    }

    /**
     * Set post-filter feedback gain
     * @param {number} value - Normalized 0-1, maps to 0-0.99
     */
    setFilterGain(value) {
        this.filterGain = value * 0.99;
    }

    /**
     * Mix feedback signals
     * @param {number} delay1Output - Output from delay line 1
     * @param {number} delay2Output - Output from delay line 2
     * @param {number} filterOutput - Output from filter
     * @returns {number} Mixed feedback signal
     */
    process(delay1Output, delay2Output, filterOutput) {
        return delay1Output * this.delay1Gain +
               delay2Output * this.delay2Gain +
               filterOutput * this.filterGain;
    }

    /**
     * Reset state (called on note-on)
     */
    reset() {
        // No internal state to reset
    }
}
</file>

<file path="src/audio/modules/FilterModule.js">
// FilterModule.js
// State-variable filter with morphable response (LP/BP/HP)

export class FilterModule {
    constructor(sampleRate = 44100) {
        this.sampleRate = sampleRate;

        // Filter parameters
        this.frequency = 1000;  // Hz
        this.q = 1.0;           // Quality factor
        this.shape = 0.0;       // 0=LP, 0.5=BP, 1=HP

        // State variables
        this.low = 0;
        this.band = 0;
        this.high = 0;

        // Previous values for stability
        this.prevLow = 0;
        this.prevBand = 0;
    }

    /**
     * Set filter frequency
     * @param {number} value - Normalized 0-1, maps to 20-20000 Hz (exponential)
     */
    setFrequency(value) {
        // Exponential mapping for perceptually linear frequency control
        this.frequency = 20 * Math.pow(1000, value);
    }

    /**
     * Set filter Q (resonance)
     * @param {number} value - Normalized 0-1, maps to 0.5-20 (exponential)
     */
    setQ(value) {
        // Exponential mapping for Q
        this.q = 0.5 * Math.pow(40, value);
    }

    /**
     * Set filter shape
     * @param {number} value - Normalized 0-1
     *                         0.0 = Lowpass
     *                         0.5 = Bandpass
     *                         1.0 = Highpass
     */
    setShape(value) {
        this.shape = Math.max(0, Math.min(1, value));
    }

    /**
     * Process one sample through the state-variable filter
     * @param {number} input - Input sample
     * @returns {number} Filtered output
     */
    process(input) {
        // Calculate filter coefficients
        const f = 2 * Math.sin(Math.PI * this.frequency / this.sampleRate);
        const qInv = 1 / Math.max(0.5, this.q);

        // State-variable filter equations
        // These equations implement a resonant filter in three outputs
        this.low = this.low + f * this.band;
        this.high = input - this.low - qInv * this.band;
        this.band = f * this.high + this.band;

        // Stability check: prevent NaN or infinity
        if (!isFinite(this.low)) this.low = 0;
        if (!isFinite(this.band)) this.band = 0;
        if (!isFinite(this.high)) this.high = 0;

        // Morph between filter responses based on shape parameter
        let output;

        if (this.shape < 0.5) {
            // Blend lowpass â†’ bandpass (0.0 to 0.5)
            const mix = this.shape * 2;
            output = this.low * (1 - mix) + this.band * mix;
        } else {
            // Blend bandpass â†’ highpass (0.5 to 1.0)
            const mix = (this.shape - 0.5) * 2;
            output = this.band * (1 - mix) + this.high * mix;
        }

        return output;
    }

    /**
     * Reset state (called on note-on)
     */
    reset() {
        this.low = 0;
        this.band = 0;
        this.high = 0;
        this.prevLow = 0;
        this.prevBand = 0;
    }
}
</file>

<file path="src/audio/modules/InterfaceModule.js">
// InterfaceModule.js
// Physical interface modeling: Pluck, Hit, Reed, Flute, Brass

export const InterfaceType = {
    PLUCK: 0,
    HIT: 1,
    REED: 2,
    FLUTE: 3,
    BRASS: 4,
    BOW: 5,
    BELL: 6,
    DRUM: 7
};

export class InterfaceModule {
    constructor() {
        this.type = InterfaceType.REED;  // Default to reed
        this.intensity = 0.5;

        // State for pluck mode
        this.lastPeak = 0;
        this.peakDecay = 0.999;
        this.prevInput = 0;

        // State for bow/bell/drum
        this.bowState = 0;
        this.bellPhase = 0;
        this.drumEnergy = 0;

        // Constants for fast tanh approximation
        this.TANH_CLIP_THRESHOLD = 3;
        this.TANH_NUMERATOR_CONSTANT = 27;
        this.TANH_DENOMINATOR_SCALE = 9;
    }

    /**
     * Set interface type
     * @param {number} type - InterfaceType enum value
     */
    setType(type) {
        if (type >= InterfaceType.PLUCK && type <= InterfaceType.BRASS) {
            this.type = type;
        }
    }

    /**
     * Set intensity parameter
     * @param {number} value - Normalized 0-1
     */
    setIntensity(value) {
        this.intensity = Math.max(0, Math.min(1, value));
    }

    /**
     * Fast tanh approximation
     * @param {number} x - Input value
     * @returns {number} Approximated tanh(x)
     */
    fastTanh(x) {
        if (x > this.TANH_CLIP_THRESHOLD) return 1;
        if (x < -this.TANH_CLIP_THRESHOLD) return -1;

        const x2 = x * x;
        return x * (this.TANH_NUMERATOR_CONSTANT + x2) /
               (this.TANH_NUMERATOR_CONSTANT + this.TANH_DENOMINATOR_SCALE * x2);
    }

    /**
     * Process pluck interface
     * One-way filter: pass initial impulse, dampen subsequent
     */
    processPluck(input) {
        const brightness = 0.2 + this.intensity * 0.45;
        let response;

        if (Math.abs(input) > Math.abs(this.lastPeak)) {
            // Let the first spike through but brighten it slightly
            this.lastPeak = input;
            response = input;
        } else {
            this.lastPeak *= this.peakDecay;
            const transient = (input - this.prevInput) * brightness;
            const damp = 0.35 + (1 - this.intensity) * 0.45;
            response = input * damp + transient;
        }

        this.prevInput = input;
        return Math.max(-1, Math.min(1, response));
    }

    /**
     * Process hit interface
     * Sharp waveshaper with adjustable hardness
     */
    processHit(input) {
        const drive = 2 + this.intensity * 8;
        const folded = Math.sin(input * drive * Math.PI * 0.5);
        const hardness = 0.35 + this.intensity * 0.55;
        const shaped = Math.sign(folded) * Math.pow(Math.abs(folded), hardness);
        return Math.max(-1, Math.min(1, shaped));
    }

    /**
     * Process reed interface
     * Clarinet-style cubic nonlinearity
     */
    processReed(input) {
        const stiffness = 2.5 + this.intensity * 10;
        const bias = (this.intensity - 0.5) * 0.25;
        const excited = (input + bias) * stiffness;
        const core = this.fastTanh(excited);
        const gain = 0.6 + this.intensity * 0.5;
        return Math.max(-1, Math.min(1, core * gain - bias * 0.3));
    }

    /**
     * Process flute interface
     * Soft symmetric nonlinearity (jet instability)
     */
    processFlute(input) {
        const softness = 0.45 + this.intensity * 0.4;
        const breath = (Math.random() * 2 - 1) * this.intensity * 0.04;
        const mixed = (input + breath) * softness;
        const shaped = mixed - (mixed * mixed * mixed) * 0.35;
        return Math.max(-0.49, Math.min(0.49, shaped));
    }

    /**
     * Process brass interface
     * Asymmetric lip model (different + and - slopes)
     */
    processBrass(input) {
        const drive = 1.5 + this.intensity * 5;
        const asymmetry = 0.4 + this.intensity * 0.5;
        let shaped;

        if (input >= 0) {
            const lifted = input * drive + (0.2 + this.intensity * 0.35);
            shaped = this.fastTanh(Math.max(lifted, 0));
        } else {
            const compressed = -input * (drive * (0.4 + this.intensity * 0.4));
            shaped = -Math.pow(Math.min(compressed, 1.5), 1.3) * (0.35 + (1 - this.intensity) * 0.25);
        }

        const buzz = this.fastTanh(shaped * (1.2 + this.intensity * 1.5));
        return Math.max(-1, Math.min(1, buzz + this.intensity * 0.05));
    }

    /**
     * Process bow interface
     * Stick-slip friction with controllable bite and noise
     */
    processBow(input) {
        const bowVelocity = this.intensity * 0.9 + 0.2;
        const slip = input - this.bowState;
        const friction = this.fastTanh(slip * (6 + this.intensity * 12));
        const grit = (Math.random() * 2 - 1) * this.intensity * 0.012;
        const output = friction * (0.55 + this.intensity * 0.35) + slip * 0.25 + grit;
        const stick = 0.8 - this.intensity * 0.25;
        this.bowState = this.bowState * stick + (input + friction * bowVelocity * 0.05) * (1 - stick);
        return Math.max(-1, Math.min(1, output));
    }

    /**
     * Process bell interface
     * Metallic waveshaping with evolving phase
     */
    processBell(input) {
        this.bellPhase += 0.1 + this.intensity * 0.25;
        if (this.bellPhase > Math.PI * 2) this.bellPhase -= Math.PI * 2;
        const harmonicSpread = 6 + this.intensity * 14;
        const even = Math.sin(input * harmonicSpread + this.bellPhase) * (0.4 + this.intensity * 0.4);
        const odd = Math.sin(input * (harmonicSpread * 0.5 + 2)) * (0.2 + this.intensity * 0.3);
        const bright = this.fastTanh((even + odd) * (1.1 + this.intensity * 0.6));
        return Math.max(-1, Math.min(1, bright));
    }

    /**
     * Process drum interface
     * Energy accumulator with noisy drive
     */
    processDrum(input) {
        const drive = 1.2 + this.intensity * 2.2;
        const noise = (Math.random() * 2 - 1) * (0.02 + this.intensity * 0.06);
        this.drumEnergy = this.drumEnergy * (0.7 - this.intensity * 0.2) + Math.abs(input) * (0.6 + this.intensity * 0.7);
        const hit = Math.tanh(input * drive) + noise;
        const output = hit * (0.4 + this.intensity * 0.4) + Math.sign(hit) * Math.min(0.8, this.drumEnergy * 0.6);
        return Math.max(-1, Math.min(1, output));
    }

    /**
     * Process one sample through selected interface
     * @param {number} input - Input sample
     * @returns {number} Processed output
     */
    process(input) {
        switch (this.type) {
            case InterfaceType.PLUCK:
                return this.processPluck(input);
            case InterfaceType.HIT:
                return this.processHit(input);
            case InterfaceType.REED:
                return this.processReed(input);
            case InterfaceType.FLUTE:
                return this.processFlute(input);
            case InterfaceType.BRASS:
                return this.processBrass(input);
            case InterfaceType.BOW:
                return this.processBow(input);
            case InterfaceType.BELL:
                return this.processBell(input);
            case InterfaceType.DRUM:
                return this.processDrum(input);
            default:
                return input;
        }
    }

    /**
     * Reset state (called on note-on)
     */
    reset() {
        this.lastPeak = 0;
        this.prevInput = 0;
        this.bowState = 0;
        this.bellPhase = 0;
        this.drumEnergy = 0;
    }
}
</file>

<file path="src/audio/modules/ModulationModule.js">
// ModulationModule.js
// LFO with bipolar AM/FM control

export class ModulationModule {
    constructor(sampleRate = 44100) {
        this.sampleRate = sampleRate;

        // LFO parameters
        this.lfoFrequency = 5;     // Hz
        this.lfoPhase = 0;

        // Modulation control (bipolar)
        // < 0.5: AM (amplitude modulation)
        // = 0.5: No modulation
        // > 0.5: FM (frequency modulation)
        this.typeLevel = 0.5;

        // Derived values
        this.amDepth = 0;    // 0-1
        this.fmDepth = 0;    // 0-1
    }

    /**
     * Set LFO frequency
     * @param {number} value - Normalized 0-1, maps to 0.1-20 Hz (exponential)
     */
    setFrequency(value) {
        // Exponential mapping
        this.lfoFrequency = 0.1 * Math.pow(200, value);
    }

    /**
     * Set modulation type and level (bipolar control)
     * @param {number} value - Normalized 0-1
     *                         0.0 = Max AM
     *                         0.5 = No modulation
     *                         1.0 = Max FM
     */
    setTypeLevel(value) {
        this.typeLevel = Math.max(0, Math.min(1, value));

        if (value < 0.5) {
            // AM mode: 0.0 -> 0.5 maps to 100% -> 0% AM
            this.amDepth = (0.5 - value) * 2;
            this.fmDepth = 0;
        } else {
            // FM mode: 0.5 -> 1.0 maps to 0% -> 100% FM
            this.amDepth = 0;
            this.fmDepth = (value - 0.5) * 2;
        }
    }

    /**
     * Process one sample and generate LFO
     * @returns {Object} {lfo: number, am: number, fm: number}
     *                   lfo: raw LFO value (-1 to +1)
     *                   am: amplitude multiplier (0-1)
     *                   fm: frequency multiplier (0.9-1.1)
     */
    process() {
        // Generate sine wave LFO
        const phaseIncrement = (this.lfoFrequency * 2 * Math.PI) / this.sampleRate;
        this.lfoPhase += phaseIncrement;

        if (this.lfoPhase > 2 * Math.PI) {
            this.lfoPhase -= 2 * Math.PI;
        }

        const lfo = Math.sin(this.lfoPhase);

        // Calculate AM multiplier (0-1 range, modulates amplitude)
        // When amDepth = 1, lfo varies from 0 to 1
        // When amDepth = 0, stays at 1
        const am = 1 - this.amDepth * 0.5 + (lfo * this.amDepth * 0.5);

        // Calculate FM multiplier (varies pitch)
        // When fmDepth = 1, lfo varies frequency by Â±10%
        // When fmDepth = 0, stays at 1
        const fm = 1 + (lfo * this.fmDepth * 0.1);

        return { lfo, am, fm };
    }

    /**
     * Reset state (called on note-on)
     */
    reset() {
        this.lfoPhase = 0;
    }
}
</file>

<file path="src/audio/modules/ReverbModule.js">
// ReverbModule.js
// Simple Schroeder reverb with Size and Level controls

export class ReverbModule {
    constructor(sampleRate) {
        this.sampleRate = sampleRate;

        // Parameters
        this.size = 0.5;        // Room size (0-1)
        this.level = 0.3;       // Wet/dry mix (0-1)

        // Comb filter delays (in samples) - scaled by size
        this.combDelays = [
            Math.floor(0.0297 * sampleRate),  // ~29.7ms
            Math.floor(0.0371 * sampleRate),  // ~37.1ms
            Math.floor(0.0411 * sampleRate),  // ~41.1ms
            Math.floor(0.0437 * sampleRate)   // ~43.7ms
        ];

        // Allpass filter delays (in samples)
        this.allpassDelays = [
            Math.floor(0.005 * sampleRate),   // ~5ms
            Math.floor(0.0017 * sampleRate)   // ~1.7ms
        ];

        // Initialize buffers
        this.combBuffers = this.combDelays.map(len => new Float32Array(len));
        this.combIndices = new Array(this.combDelays.length).fill(0);

        this.allpassBuffers = this.allpassDelays.map(len => new Float32Array(len));
        this.allpassIndices = new Array(this.allpassDelays.length).fill(0);
    }

    setSize(value) {
        // Size affects feedback amount (0.5 = small room, 1.0 = large room)
        this.size = Math.max(0, Math.min(1, value));
    }

    setLevel(value) {
        // Wet/dry mix level
        this.level = Math.max(0, Math.min(1, value));
    }

    process(input) {
        // Comb filters in parallel
        let combSum = 0;
        const feedback = 0.7 + this.size * 0.28; // 0.7 to 0.98

        for (let i = 0; i < this.combBuffers.length; i++) {
            const buffer = this.combBuffers[i];
            const index = this.combIndices[i];
            const delay = this.combDelays[i];

            // Read from delay line
            const delayed = buffer[index];

            // Write input + feedback to delay line
            buffer[index] = input + delayed * feedback;

            // Add to output sum
            combSum += delayed;

            // Advance index
            this.combIndices[i] = (index + 1) % delay;
        }

        // Average the comb outputs
        let output = combSum / this.combBuffers.length;

        // Allpass filters in series
        for (let i = 0; i < this.allpassBuffers.length; i++) {
            const buffer = this.allpassBuffers[i];
            const index = this.allpassIndices[i];
            const delay = this.allpassDelays[i];

            // Read from delay line
            const delayed = buffer[index];

            // Allpass feedback coefficient
            const g = 0.5;

            // Allpass filter equation
            const newOutput = -output * g + delayed;
            buffer[index] = output + delayed * g;
            output = newOutput;

            // Advance index
            this.allpassIndices[i] = (index + 1) % delay;
        }

        // Wet/dry mix
        return input * (1 - this.level) + output * this.level;
    }

    reset() {
        // Clear all buffers
        this.combBuffers.forEach(buffer => buffer.fill(0));
        this.allpassBuffers.forEach(buffer => buffer.fill(0));

        // Reset indices
        this.combIndices.fill(0);
        this.allpassIndices.fill(0);
    }
}
</file>

<file path="src/audio/modules/SourcesModule.js">
// SourcesModule.js
// Generates excitation signals: DC, White Noise, and Sawtooth Tone

export class SourcesModule {
    constructor(sampleRate = 44100) {
        this.sampleRate = sampleRate;

        // Source levels (0-1)
        this.dcLevel = 0.5;
        this.noiseLevel = 0.15;
        this.toneLevel = 0.0;

        // Sawtooth state
        this.sawtoothPhase = 0;
        this.sawtoothFrequency = 440;
    }

    /**
     * Set DC level (constant pressure source)
     * @param {number} value - Level 0-1
     */
    setDCLevel(value) {
        this.dcLevel = Math.max(0, Math.min(1, value));
    }

    /**
     * Set white noise level (turbulence source)
     * @param {number} value - Level 0-1
     */
    setNoiseLevel(value) {
        this.noiseLevel = Math.max(0, Math.min(1, value));
    }

    /**
     * Set sawtooth tone level (harmonic source)
     * @param {number} value - Level 0-1
     */
    setToneLevel(value) {
        this.toneLevel = Math.max(0, Math.min(1, value));
    }

    /**
     * Process one sample
     * @param {number} cv - Control voltage (frequency in Hz)
     * @returns {number} Mixed output of all sources
     */
    process(cv) {
        // Update sawtooth frequency from CV
        this.sawtoothFrequency = cv;

        // Generate DC (constant)
        const dc = this.dcLevel;

        // Generate white noise
        const noise = (Math.random() * 2 - 1) * this.noiseLevel;

        // Generate naive sawtooth (-1 to +1)
        const phaseIncrement = this.sawtoothFrequency / this.sampleRate;
        this.sawtoothPhase += phaseIncrement;
        if (this.sawtoothPhase >= 1.0) {
            this.sawtoothPhase -= 1.0;
        }
        const sawtooth = (this.sawtoothPhase * 2 - 1) * this.toneLevel;

        // Sum all sources
        return dc + noise + sawtooth;
    }

    /**
     * Reset state (called on note-on)
     */
    reset() {
        this.sawtoothPhase = 0;
    }
}
</file>

<file path="src/audio/pm-synth-worklet.js">
// pm-synth-worklet.js
// AudioWorklet processor for the Stove engine

// Import modules (worklet context)
import { SourcesModule } from './modules/SourcesModule.js';
import { EnvelopeModule } from './modules/EnvelopeModule.js';
import { InterfaceModule, InterfaceType } from './modules/InterfaceModule.js';
import { DelayLinesModule } from './modules/DelayLinesModule.js';
import { FeedbackModule } from './modules/FeedbackModule.js';
import { FilterModule } from './modules/FilterModule.js';
import { ModulationModule } from './modules/ModulationModule.js';
import { ReverbModule } from './modules/ReverbModule.js';

const sampleRate = globalThis.sampleRate;

class PMSynthWorkletProcessor extends AudioWorkletProcessor {
    constructor() {
        super();

        // Instantiate all modules
        this.sources = new SourcesModule(sampleRate);
        this.envelope = new EnvelopeModule(sampleRate);
        this.interface = new InterfaceModule();
        this.delayLines = new DelayLinesModule(sampleRate);
        this.feedback = new FeedbackModule();
        this.filter = new FilterModule(sampleRate);
        this.modulation = new ModulationModule(sampleRate);
        this.reverb = new ReverbModule(sampleRate);

        // State
        this.frequency = 440;
        this.gate = false;
        this.isPlaying = false;
        this.outputGain = 0.5;
        this.dcBlockerX1 = 0;
        this.dcBlockerY1 = 0;
        this.prevDelayOutputs = { delay1: 0, delay2: 0 };
        this.prevFilterOutput = 0;

        // Handle messages from main thread
        this.port.onmessage = (e) => {
            const { type, data } = e.data;

            switch (type) {
                case 'noteOn':
                    this.noteOn(data.frequency);
                    break;
                case 'noteOff':
                    this.noteOff();
                    break;
                case 'setParameter':
                    this.setParameter(data.param, data.value);
                    break;
            }
        };
    }

    noteOn(frequency) {
        this.frequency = frequency;
        this.gate = true;
        this.isPlaying = true;

        // Reset all modules
        this.sources.reset();
        this.envelope.reset();
        this.interface.reset();
        this.delayLines.reset();
        this.feedback.reset();
        this.filter.reset();
        this.modulation.reset();
        this.reverb.reset();
        this.dcBlockerX1 = 0;
        this.dcBlockerY1 = 0;
        this.prevDelayOutputs.delay1 = 0;
        this.prevDelayOutputs.delay2 = 0;
        this.prevFilterOutput = 0;

        // Set gate
        this.envelope.setGate(true);
    }

    noteOff() {
        this.gate = false;
        this.envelope.setGate(false);
    }

    setParameter(param, value) {
        switch (param) {
            // Sources
            case 'dcLevel':
                this.sources.setDCLevel(value);
                break;
            case 'noiseLevel':
                this.sources.setNoiseLevel(value);
                break;
            case 'toneLevel':
                this.sources.setToneLevel(value);
                break;

            // Envelope
            case 'attack':
                this.envelope.setAttack(value);
                break;
            case 'release':
                this.envelope.setRelease(value);
                break;

            // Interface
            case 'interfaceType':
                this.interface.setType(value);
                break;
            case 'interfaceIntensity':
                this.interface.setIntensity(value);
                break;

            // Delay Lines
            case 'tuning':
                this.delayLines.setTuning(value);
                break;
            case 'ratio':
                this.delayLines.setRatio(value);
                break;

            // Feedback
            case 'delay1Feedback':
                this.feedback.setDelay1Gain(value);
                break;
            case 'delay2Feedback':
                this.feedback.setDelay2Gain(value);
                break;
            case 'filterFeedback':
                this.feedback.setFilterGain(value);
                break;

            // Filter
            case 'filterFrequency':
                this.filter.setFrequency(value);
                break;
            case 'filterQ':
                this.filter.setQ(value);
                break;
            case 'filterShape':
                this.filter.setShape(value);
                break;

            // Modulation
            case 'lfoFrequency':
                this.modulation.setFrequency(value);
                break;
            case 'modulationTypeLevel':
                this.modulation.setTypeLevel(value);
                break;

            // Reverb
            case 'reverbSize':
                this.reverb.setSize(value);
                break;
            case 'reverbLevel':
                this.reverb.setLevel(value);
                break;
        }
    }

    processSample() {
        if (!this.isPlaying) return 0;

        // Get modulation values
        const mod = this.modulation.process();

        // Apply FM to frequency
        const modulatedFreq = this.frequency * mod.fm;

        // Generate sources (DC, Noise, Tone)
        const sourceSignal = this.sources.process(modulatedFreq);

        // Apply envelope
        const env = this.envelope.process();
        const envelopedSignal = sourceSignal * env;

        // Apply interface nonlinearity
        const interfaceOutput = this.interface.process(envelopedSignal);

        // Mix feedback from previous delay outputs and filter
        const feedbackSignal = this.feedback.process(
            this.prevDelayOutputs.delay1,
            this.prevDelayOutputs.delay2,
            this.prevFilterOutput
        );

        // Combine interface output with feedback and remove DC offset
        const rawDelayInput = interfaceOutput + feedbackSignal;
        const delayInput = this.dcBlock(rawDelayInput);
        const clampedDelayInput = Math.max(-1, Math.min(1, delayInput));

        // Process through delay lines with actual input
        const finalDelayOutputs = this.delayLines.process(clampedDelayInput, this.frequency);

        // Mix delay outputs
        const delayMix = (finalDelayOutputs.delay1 + finalDelayOutputs.delay2) * 0.5;

        // Apply filter
        const filterOutput = this.filter.process(delayMix);

        // Apply AM and output gain
        const preReverbOutput = filterOutput * mod.am * this.outputGain;

        // Apply reverb (at end of signal path)
        const output = this.reverb.process(preReverbOutput);

        // Store outputs for next iteration feedback
        this.prevDelayOutputs.delay1 = finalDelayOutputs.delay1;
        this.prevDelayOutputs.delay2 = finalDelayOutputs.delay2;
        this.prevFilterOutput = filterOutput;

        if (!this.envelope.isPlaying() && Math.abs(output) < 1e-5 &&
            Math.abs(this.prevDelayOutputs.delay1) < 1e-5 && Math.abs(this.prevDelayOutputs.delay2) < 1e-5) {
            this.isPlaying = false;
        }

        return output;
    }

    dcBlock(sample) {
        const y = sample - this.dcBlockerX1 + 0.995 * this.dcBlockerY1;
        this.dcBlockerX1 = sample;
        this.dcBlockerY1 = y;
        return y;
    }

    process(inputs, outputs, parameters) {
        const output = outputs[0];
        const channel = output[0];

        for (let i = 0; i < channel.length; i++) {
            channel[i] = this.processSample();
        }

        return true; // Keep processor alive
    }
}

registerProcessor('pm-synth-worklet', PMSynthWorkletProcessor);
</file>

<file path="src/audio/PMSynthEngine.js">
// PMSynthEngine.js
// Physical Modeling Synthesizer Engine - integrates all modules

import { SourcesModule } from './modules/SourcesModule.js';
import { EnvelopeModule } from './modules/EnvelopeModule.js';
import { InterfaceModule, InterfaceType } from './modules/InterfaceModule.js';
import { DelayLinesModule } from './modules/DelayLinesModule.js';
import { FeedbackModule } from './modules/FeedbackModule.js';
import { FilterModule } from './modules/FilterModule.js';
import { ModulationModule } from './modules/ModulationModule.js';
import { ReverbModule } from './modules/ReverbModule.js';

export { InterfaceType };

export class PMSynthEngine {
    constructor(sampleRate = 44100) {
        this.sampleRate = sampleRate;

        // Instantiate all modules
        this.sources = new SourcesModule(sampleRate);
        this.envelope = new EnvelopeModule(sampleRate);
        this.interface = new InterfaceModule();
        this.delayLines = new DelayLinesModule(sampleRate);
        this.feedback = new FeedbackModule();
        this.filter = new FilterModule(sampleRate);
        this.modulation = new ModulationModule(sampleRate);
        this.reverb = new ReverbModule(sampleRate);

        // Current state
        this.frequency = 440;
        this.gate = false;
        this.isPlaying = false;

        // Output scaling
        this.outputGain = 0.5;

        // DC blocker state
        this.dcBlockerX1 = 0;
        this.dcBlockerY1 = 0;

        // Feedback memory
        this.prevDelayOutputs = { delay1: 0, delay2: 0 };
        this.prevFilterOutput = 0;
    }

    /**
     * Note on - trigger the synth
     * @param {number} frequency - Note frequency in Hz
     */
    noteOn(frequency) {
        this.frequency = frequency;
        this.gate = true;
        this.isPlaying = true;

        // Reset all modules
        this.sources.reset();
        this.envelope.reset();
        this.interface.reset();
        this.delayLines.reset();
        this.feedback.reset();
        this.filter.reset();
        this.modulation.reset();
        this.reverb.reset();
        this.dcBlockerX1 = 0;
        this.dcBlockerY1 = 0;
        this.prevDelayOutputs.delay1 = 0;
        this.prevDelayOutputs.delay2 = 0;
        this.prevFilterOutput = 0;

        // Set gate
        this.envelope.setGate(true);
    }

    /**
     * Note off - release the synth
     */
    noteOff() {
        this.gate = false;
        this.envelope.setGate(false);
    }

    /**
     * Process one sample
     * @returns {number} Output sample
     */
    process() {
        if (!this.isPlaying) return 0;

        // Get modulation values
        const mod = this.modulation.process();

        // Apply FM to frequency
        const modulatedFreq = this.frequency * mod.fm;

        // Generate sources (DC, Noise, Tone)
        const sourceSignal = this.sources.process(modulatedFreq);

        // Apply envelope
        const env = this.envelope.process();
        const envelopedSignal = sourceSignal * env;

        // Apply interface nonlinearity
        const interfaceOutput = this.interface.process(envelopedSignal);

        // Mix feedback from previous delay outputs and filter
        const feedbackSignal = this.feedback.process(
            this.prevDelayOutputs.delay1,
            this.prevDelayOutputs.delay2,
            this.prevFilterOutput
        );

        // Combine interface output with feedback and remove DC offset
        const rawDelayInput = interfaceOutput + feedbackSignal;
        const delayInput = this.dcBlock(rawDelayInput);
        const clampedDelayInput = Math.max(-1, Math.min(1, delayInput));

        // Process through delay lines with the actual input
        const finalDelayOutputs = this.delayLines.process(clampedDelayInput, this.frequency);

        // Mix delay outputs (simple average)
        const delayMix = (finalDelayOutputs.delay1 + finalDelayOutputs.delay2) * 0.5;

        // Apply filter
        const filterOutput = this.filter.process(delayMix);

        // Apply AM
        const preReverbOutput = filterOutput * mod.am * this.outputGain;

        // Apply reverb (at end of signal path)
        const output = this.reverb.process(preReverbOutput);

        // Store outputs for next iteration feedback
        this.prevDelayOutputs.delay1 = finalDelayOutputs.delay1;
        this.prevDelayOutputs.delay2 = finalDelayOutputs.delay2;
        this.prevFilterOutput = filterOutput;

        // Determine if voice can be turned off (envelope finished and tail faded)
        if (!this.envelope.isPlaying() && Math.abs(output) < 1e-5 &&
            Math.abs(this.prevDelayOutputs.delay1) < 1e-5 && Math.abs(this.prevDelayOutputs.delay2) < 1e-5) {
            this.isPlaying = false;
        }

        return output;
    }

    dcBlock(sample) {
        const y = sample - this.dcBlockerX1 + 0.995 * this.dcBlockerY1;
        this.dcBlockerX1 = sample;
        this.dcBlockerY1 = y;
        return y;
    }

    // ===== Parameter Setters =====

    // Sources
    setDCLevel(value) { this.sources.setDCLevel(value); }
    setNoiseLevel(value) { this.sources.setNoiseLevel(value); }
    setToneLevel(value) { this.sources.setToneLevel(value); }

    // Envelope
    setAttack(value) { this.envelope.setAttack(value); }
    setRelease(value) { this.envelope.setRelease(value); }

    // Interface
    setInterfaceType(type) { this.interface.setType(type); }
    setInterfaceIntensity(value) { this.interface.setIntensity(value); }

    // Delay Lines
    setTuning(value) { this.delayLines.setTuning(value); }
    setRatio(value) { this.delayLines.setRatio(value); }

    // Feedback
    setDelay1Feedback(value) { this.feedback.setDelay1Gain(value); }
    setDelay2Feedback(value) { this.feedback.setDelay2Gain(value); }
    setFilterFeedback(value) { this.feedback.setFilterGain(value); }

    // Filter
    setFilterFrequency(value) { this.filter.setFrequency(value); }
    setFilterQ(value) { this.filter.setQ(value); }
    setFilterShape(value) { this.filter.setShape(value); }

    // Modulation
    setLFOFrequency(value) { this.modulation.setFrequency(value); }
    setModulationTypeLevel(value) { this.modulation.setTypeLevel(value); }

    // Reverb
    setReverbSize(value) { this.reverb.setSize(value); }
    setReverbLevel(value) { this.reverb.setLevel(value); }

    /**
     * Get current playing status
     * @returns {boolean}
     */
    getIsPlaying() {
        return this.isPlaying;
    }
}
</file>

<file path="src/audio/PMSynthProcessor.js">
// PMSynthProcessor.js
// Audio processor using Web Audio API AudioWorklet (with ScriptProcessor fallback)

import { PMSynthEngine } from './PMSynthEngine.js';
// @ts-ignore - Vite special import for worklet URL

export class PMSynthProcessor {
    constructor() {
        this.audioContext = null;
        this.workletNode = null;
        this.scriptNode = null;
        this.engine = null;
        this.analyser = null;
        this.gainNode = null;
        this.isActive = false;
        this.useWorklet = false;
    }

    async initialize() {
        console.log('[PMSynthProcessor] Initializing...');
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        await this._installIOSUnlock(this.audioContext);
        console.log(`[PMSynthProcessor] audioContext.state: ${this.audioContext.state}`);

        // Explicitly resume context
        if (this.audioContext.state !== 'running') {
            await this.audioContext.resume();
            console.log(`[PMSynthProcessor] audioContext resumed, state: ${this.audioContext.state}`);
        }

        // Create gain node for volume control
        this.gainNode = this.audioContext.createGain();
        this.gainNode.gain.value = 1.0;

        // Create analyser for visualization
        this.analyser = this.audioContext.createAnalyser();
        this.analyser.fftSize = 2048;

        // Try to use AudioWorklet (modern, better performance)
        try {
            const workletUrl = new URL('./pm-synth-worklet.js', import.meta.url);
            await this.audioContext.audioWorklet.addModule(workletUrl);

            this.workletNode = new AudioWorkletNode(this.audioContext, 'pm-synth-worklet');
            this.workletNode.connect(this.gainNode);
            this.gainNode.connect(this.analyser);
            this.analyser.connect(this.audioContext.destination);

            this.useWorklet = true;
            console.log('[PMSynthProcessor] Using AudioWorklet');
        } catch (error) {
            console.warn('[PMSynthProcessor] AudioWorklet not available, using ScriptProcessor:', error);
            this.engine = new PMSynthEngine(this.audioContext.sampleRate);

            this.scriptNode = this.audioContext.createScriptProcessor(2048, 0, 1);
            this.scriptNode.onaudioprocess = (event) => {
                const output = event.outputBuffer.getChannelData(0);
                for (let i = 0; i < output.length; i++) {
                    output[i] = this.engine.process();
                }
            };

            this.scriptNode.connect(this.gainNode);
            this.gainNode.connect(this.analyser);
            this.analyser.connect(this.audioContext.destination);

            this.useWorklet = false;
            console.log('[PMSynthProcessor] Using ScriptProcessorNode');
        }

        this.isActive = true;
    }

    async noteOn(frequency) {
        console.log(`[PMSynthProcessor] noteOn: ${frequency}Hz`);
        if (this.audioContext.state !== 'running') {
            await this.audioContext.resume();
        }

        if (this.useWorklet && this.workletNode) {
            this.workletNode.port.postMessage({
                type: 'noteOn',
                data: { frequency }
            });
        } else if (this.engine) {
            this.engine.noteOn(frequency);
        }
    }

    noteOff() {
        if (this.useWorklet && this.workletNode) {
            this.workletNode.port.postMessage({
                type: 'noteOff'
            });
        } else if (this.engine) {
            this.engine.noteOff();
        }
    }

    setParameter(param, value) {
        if (this.useWorklet && this.workletNode) {
            this.workletNode.port.postMessage({
                type: 'setParameter',
                data: { param, value }
            });
        } else if (this.engine) {
            // Map parameter names to engine methods
            switch (param) {
                case 'dcLevel': this.engine.setDCLevel(value); break;
                case 'noiseLevel': this.engine.setNoiseLevel(value); break;
                case 'toneLevel': this.engine.setToneLevel(value); break;
                case 'attack': this.engine.setAttack(value); break;
                case 'release': this.engine.setRelease(value); break;
                case 'interfaceType': this.engine.setInterfaceType(value); break;
                case 'interfaceIntensity': this.engine.setInterfaceIntensity(value); break;
                case 'tuning': this.engine.setTuning(value); break;
                case 'ratio': this.engine.setRatio(value); break;
                case 'delay1Feedback': this.engine.setDelay1Feedback(value); break;
                case 'delay2Feedback': this.engine.setDelay2Feedback(value); break;
                case 'filterFeedback': this.engine.setFilterFeedback(value); break;
                case 'filterFrequency': this.engine.setFilterFrequency(value); break;
                case 'filterQ': this.engine.setFilterQ(value); break;
                case 'filterShape': this.engine.setFilterShape(value); break;
                case 'lfoFrequency': this.engine.setLFOFrequency(value); break;
                case 'modulationTypeLevel': this.engine.setModulationTypeLevel(value); break;
            }
        }
    }

    getAnalyserData() {
        if (!this.analyser || !this.audioContext) return null;

        const timeDomain = new Float32Array(this.analyser.fftSize);
        this.analyser.getFloatTimeDomainData(timeDomain);

        const frequencyDomain = new Uint8Array(this.analyser.frequencyBinCount);
        this.analyser.getByteFrequencyData(frequencyDomain);

        return {
            timeDomain,
            frequencyDomain,
            sampleRate: this.audioContext.sampleRate
        };
    }

    async _installIOSUnlock(ctx) {
        if (!ctx) return;
        let unlocked = ctx.state === 'running';

        const cleanup = () => {
            document.removeEventListener('pointerdown', unlock, true);
            document.removeEventListener('touchstart', unlock, true);
            document.removeEventListener('keydown', unlock, true);
        };

        const unlock = async () => {
            if (unlocked) return;
            try {
                if (ctx.state !== 'running') {
                    await ctx.resume();
                }
                const b = ctx.createBuffer(1, 1, ctx.sampleRate);
                const s = ctx.createBufferSource();
                s.buffer = b;
                s.connect(ctx.destination);
                if (typeof s.start === 'function') {
                    s.start(0);
                } else if (typeof s.noteOn === 'function') {
                    s.noteOn(0);
                }
                setTimeout(() => s.disconnect(), 0);
                unlocked = true;
                cleanup();
                console.log('[PMSynthProcessor] iOS audio unlocked');
            } catch (e) {
                console.warn('[PMSynthProcessor] unlock failed', e);
            }
        };

        document.addEventListener('pointerdown', unlock, { capture: true, passive: true });
        document.addEventListener('touchstart', unlock, { capture: true, passive: true });
        document.addEventListener('keydown', unlock, { capture: true });
        ctx.onstatechange = () => console.log('[PMSynthProcessor] state:', ctx.state);

        await unlock();
    }

    shutdown() {
        if (this.workletNode) {
            this.workletNode.disconnect();
        }
        if (this.scriptNode) {
            this.scriptNode.disconnect();
        }
        if (this.gainNode) {
            this.gainNode.disconnect();
        }
        if (this.analyser) {
            this.analyser.disconnect();
        }
        if (this.audioContext) {
            this.audioContext.close();
        }
        this.isActive = false;
    }
}
</file>

<file path="src/ui/KeyboardController.js">
// KeyboardController.js
// Handles keyboard interactions (both visual and computer keyboard)

export class KeyboardController {
    constructor(containerElement, onNoteOn, onNoteOff) {
        this.container = containerElement;
        this.onNoteOn = onNoteOn;
        this.onNoteOff = onNoteOff;
        this.activeKeys = new Set();
        this.keyMap = this.createKeyMap();

        this.setupListeners();
    }

    createKeyMap() {
        // Map computer keyboard to musical notes (2 octaves)
        return {
            // First octave (C4-B4)
            'a': 'C4',
            'w': 'C#4',
            's': 'D4',
            'e': 'D#4',
            'd': 'E4',
            'f': 'F4',
            't': 'F#4',
            'g': 'G4',
            'y': 'G#4',
            'h': 'A4',
            'u': 'A#4',
            'j': 'B4',
            // Second octave (C5-C6)
            'k': 'C5',
            'o': 'C#5',
            'l': 'D5',
            'p': 'D#5',
            ';': 'E5',
            "'": 'F5',
            ']': 'F#5',
            'z': 'G5',
            'x': 'G#5',
            'c': 'A5',
            'v': 'A#5',
            'b': 'B5',
            'n': 'C6'
        };
    }

    noteToFrequency(note) {
        const notes = {
            // Octave 4 (C4-B4)
            'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13,
            'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00,
            'G#4': 415.30, 'A4': 440.00, 'A#4': 466.16, 'B4': 493.88,
            // Octave 5 (C5-B5)
            'C5': 523.25, 'C#5': 554.37, 'D5': 587.33, 'D#5': 622.25,
            'E5': 659.25, 'F5': 698.46, 'F#5': 739.99, 'G5': 783.99,
            'G#5': 830.61, 'A5': 880.00, 'A#5': 932.33, 'B5': 987.77,
            // Octave 6 (C6)
            'C6': 1046.50
        };
        return notes[note] || 440;
    }

    setupListeners() {
        // Mouse/touch events on visual keyboard
        const keys = this.container.querySelectorAll('.key');

        keys.forEach(key => {
            const note = key.dataset.note;

            key.addEventListener('mousedown', (e) => {
                e.preventDefault();
                this.pressKey(note);
            });

            key.addEventListener('mouseup', () => {
                this.releaseKey(note);
            });

            key.addEventListener('mouseleave', () => {
                if (this.activeKeys.has(note)) {
                    this.releaseKey(note);
                }
            });

            // Touch events
            key.addEventListener('touchstart', (e) => {
                e.preventDefault();
                this.pressKey(note);
            });

            key.addEventListener('touchend', (e) => {
                e.preventDefault();
                this.releaseKey(note);
            });
        });

        // Computer keyboard events
        document.addEventListener('keydown', (e) => {
            const note = this.keyMap[e.key.toLowerCase()];
            if (note && !this.activeKeys.has(note)) {
                this.pressKey(note);
            }
        });

        document.addEventListener('keyup', (e) => {
            const note = this.keyMap[e.key.toLowerCase()];
            if (note) {
                this.releaseKey(note);
            }
        });
    }

    pressKey(note) {
        if (this.activeKeys.has(note)) return;

        console.log(`[KeyboardController] pressKey: ${note}`);
        this.activeKeys.add(note);
        const keyElement = this.container.querySelector(`[data-note="${note}"]`);
        if (keyElement) {
            keyElement.classList.add('active');
        }

        const frequency = this.noteToFrequency(note);
        try {
            this.onNoteOn(note, frequency);
        } catch (error) {
            console.error('[KeyboardController] Error calling onNoteOn:', error);
        }
    }

    releaseKey(note) {
        if (!this.activeKeys.has(note)) return;

        this.activeKeys.delete(note);
        const keyElement = this.container.querySelector(`[data-note="${note}"]`);
        if (keyElement) {
            keyElement.classList.remove('active');
        }

        this.onNoteOff(note);
    }

    releaseAllKeys() {
        this.activeKeys.forEach(note => {
            this.releaseKey(note);
        });
    }
}
</file>

<file path="src/ui/KnobController.js">
// KnobController.js
// Handles rotary knob interactions

export class KnobController {
    constructor(element, valueElement, onChange, min = 0, max = 100, defaultValue = 50, bipolar = false) {
        this.element = element;
        this.valueElement = valueElement;
        this.onChange = onChange;
        this.min = min;
        this.max = max;
        this.value = defaultValue;
        this.bipolar = bipolar;  // If true, displays centered at 50
        this.isDragging = false;
        this.startY = 0;
        this.startValue = 0;

        this.setupListeners();
        this.updateDisplay();
    }

    setupListeners() {
        this.element.addEventListener('mousedown', (e) => {
            this.isDragging = true;
            this.startY = e.clientY;
            this.startValue = this.value;
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (this.isDragging) {
                const delta = (this.startY - e.clientY) * 0.5;
                this.value = Math.max(this.min, Math.min(this.max, this.startValue + delta));
                this.updateDisplay();
                this.onChange(this.value / 100);
            }
        });

        document.addEventListener('mouseup', () => {
            this.isDragging = false;
        });

        // Touch support
        this.element.addEventListener('touchstart', (e) => {
            this.isDragging = true;
            this.startY = e.touches[0].clientY;
            this.startValue = this.value;
            e.preventDefault();
        });

        document.addEventListener('touchmove', (e) => {
            if (this.isDragging) {
                const delta = (this.startY - e.touches[0].clientY) * 0.5;
                this.value = Math.max(this.min, Math.min(this.max, this.startValue + delta));
                this.updateDisplay();
                this.onChange(this.value / 100);
            }
        });

        document.addEventListener('touchend', () => {
            this.isDragging = false;
        });

        // Double-click to reset
        this.element.addEventListener('dblclick', () => {
            this.value = (this.min + this.max) / 2;
            this.updateDisplay();
            this.onChange(this.value / 100);
        });
    }

    updateDisplay() {
        const rotation = (this.value / 100) * 270 - 135;
        this.element.style.transform = `rotate(${rotation}deg)`;

        if (this.bipolar) {
            // Display as -50 to +50 for bipolar controls
            const displayValue = Math.round(this.value - 50);
            this.valueElement.textContent = displayValue >= 0 ? `+${displayValue}` : displayValue;
        } else {
            this.valueElement.textContent = Math.round(this.value);
        }
    }

    setValue(value) {
        this.value = Math.max(this.min, Math.min(this.max, value));
        this.updateDisplay();
    }
}
</file>

<file path="src/ui/MidiController.js">
// MidiController.js
// Handles MIDI input for note on/off and future CC mapping

export class MidiController {
    constructor(onNoteOn, onNoteOff) {
        this.onNoteOn = onNoteOn;
        this.onNoteOff = onNoteOff;
        this.midiAccess = null;
        this.selectedInput = null;
        this.selectedChannel = 'all'; // 'all' or 1-16
        this.activeNotes = new Map(); // Track active MIDI notes
        this.enabled = true;
        this.onDeviceChange = null; // Callback for device list changes
        this.onActivity = null; // Callback for MIDI activity indicator
    }

    async initialize() {
        if (!navigator.requestMIDIAccess) {
            console.warn('[MidiController] Web MIDI API not supported');
            return false;
        }

        try {
            this.midiAccess = await navigator.requestMIDIAccess();
            console.log('[MidiController] MIDI access granted');

            // Listen for device connect/disconnect
            this.midiAccess.onstatechange = (e) => {
                console.log(`[MidiController] Device ${e.port.state}: ${e.port.name}`);
                if (this.onDeviceChange) {
                    this.onDeviceChange(this.getInputDevices());
                }
            };

            // Auto-select first available input
            const inputs = this.getInputDevices();
            if (inputs.length > 0) {
                this.selectInput(inputs[0].id);
            }

            return true;
        } catch (error) {
            console.error('[MidiController] Failed to initialize MIDI:', error);
            return false;
        }
    }

    getInputDevices() {
        if (!this.midiAccess) return [];

        const devices = [];
        for (const input of this.midiAccess.inputs.values()) {
            devices.push({
                id: input.id,
                name: input.name || 'Unknown Device',
                manufacturer: input.manufacturer || '',
                state: input.state
            });
        }
        return devices;
    }

    selectInput(inputId) {
        // Disconnect previous input
        if (this.selectedInput) {
            this.selectedInput.onmidimessage = null;
        }

        if (!inputId) {
            this.selectedInput = null;
            return;
        }

        // Connect to new input
        const input = this.midiAccess.inputs.get(inputId);
        if (!input) {
            console.warn(`[MidiController] Input ${inputId} not found`);
            return;
        }

        this.selectedInput = input;
        this.selectedInput.onmidimessage = (event) => this.handleMidiMessage(event);
        console.log(`[MidiController] Selected input: ${input.name}`);
    }

    setChannel(channel) {
        // channel can be 'all' or 1-16
        this.selectedChannel = channel;
        console.log(`[MidiController] Channel set to: ${channel}`);
    }

    setEnabled(enabled) {
        this.enabled = enabled;
        if (!enabled) {
            // Release all active notes
            this.releaseAllNotes();
        }
        console.log(`[MidiController] MIDI ${enabled ? 'enabled' : 'disabled'}`);
    }

    handleMidiMessage(event) {
        if (!this.enabled) return;

        const [status, data1, data2] = event.data;
        const messageType = status & 0xF0;
        const channel = (status & 0x0F) + 1; // MIDI channels are 1-16

        // Filter by channel if not set to 'all'
        if (this.selectedChannel !== 'all' && channel !== parseInt(this.selectedChannel)) {
            return;
        }

        // Trigger activity indicator
        if (this.onActivity) {
            this.onActivity();
        }

        switch (messageType) {
            case 0x90: // Note On
                if (data2 > 0) {
                    this.handleNoteOn(data1, data2);
                } else {
                    // Note On with velocity 0 is Note Off
                    this.handleNoteOff(data1);
                }
                break;

            case 0x80: // Note Off
                this.handleNoteOff(data1);
                break;

            case 0xB0: // Control Change (for future CC mapping)
                this.handleControlChange(data1, data2);
                break;

            default:
                // Ignore other MIDI messages for now
                break;
        }
    }

    handleNoteOn(midiNote, velocity) {
        const frequency = this.midiNoteToFrequency(midiNote);
        const noteName = this.midiNoteToName(midiNote);
        const normalizedVelocity = velocity / 127;

        console.log(`[MidiController] Note On: ${noteName} (${midiNote}) @ ${frequency.toFixed(2)}Hz, vel=${velocity}`);

        // Track active note
        this.activeNotes.set(midiNote, { noteName, frequency, velocity });

        // Call the note on callback
        try {
            this.onNoteOn(noteName, frequency, normalizedVelocity);
        } catch (error) {
            console.error('[MidiController] Error calling onNoteOn:', error);
        }
    }

    handleNoteOff(midiNote) {
        const noteData = this.activeNotes.get(midiNote);
        if (!noteData) return; // Note wasn't active

        console.log(`[MidiController] Note Off: ${noteData.noteName} (${midiNote})`);

        // Remove from active notes
        this.activeNotes.delete(midiNote);

        // Call the note off callback
        try {
            this.onNoteOff(noteData.noteName);
        } catch (error) {
            console.error('[MidiController] Error calling onNoteOff:', error);
        }
    }

    handleControlChange(controller, value) {
        // Placeholder for future CC mapping implementation
        console.log(`[MidiController] CC: ${controller} = ${value}`);
        // TODO: Implement CC mapping in Phase 3
    }

    releaseAllNotes() {
        // Send note off for all active notes
        for (const [midiNote, noteData] of this.activeNotes.entries()) {
            console.log(`[MidiController] Releasing stuck note: ${noteData.noteName}`);
            try {
                this.onNoteOff(noteData.noteName);
            } catch (error) {
                console.error('[MidiController] Error releasing note:', error);
            }
        }
        this.activeNotes.clear();
    }

    midiNoteToFrequency(noteNumber) {
        // A4 (MIDI note 69) = 440 Hz
        // Formula: f = 440 * 2^((n-69)/12)
        return 440 * Math.pow(2, (noteNumber - 69) / 12);
    }

    midiNoteToName(noteNumber) {
        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const octave = Math.floor(noteNumber / 12) - 1;
        const noteName = noteNames[noteNumber % 12];
        return `${noteName}${octave}`;
    }

    shutdown() {
        this.releaseAllNotes();
        if (this.selectedInput) {
            this.selectedInput.onmidimessage = null;
        }
    }
}
</file>

<file path="src/ui/RotarySwitchController.js">
// RotarySwitchController.js
// Handles rotary switch interactions (discrete positions)

export class RotarySwitchController {
    constructor(element, labelElement, positions, onChange, defaultPosition = 0) {
        this.element = element;
        this.labelElement = labelElement;
        this.positions = positions;  // Array of position labels
        this.onChange = onChange;
        this.currentPosition = defaultPosition;
        this.isDragging = false;
        this.startY = 0;
        this.startPosition = 0;

        this.setupListeners();
        this.updateDisplay();
    }

    setupListeners() {
        this.element.addEventListener('mousedown', (e) => {
            this.isDragging = true;
            this.startY = e.clientY;
            this.startPosition = this.currentPosition;
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (this.isDragging) {
                const delta = Math.floor((this.startY - e.clientY) / 30);
                const newPosition = Math.max(0, Math.min(
                    this.positions.length - 1,
                    this.startPosition + delta
                ));

                if (newPosition !== this.currentPosition) {
                    this.currentPosition = newPosition;
                    this.updateDisplay();
                    this.onChange(this.currentPosition);
                }
            }
        });

        document.addEventListener('mouseup', () => {
            this.isDragging = false;
        });

        // Touch support
        this.element.addEventListener('touchstart', (e) => {
            this.isDragging = true;
            this.startY = e.touches[0].clientY;
            this.startPosition = this.currentPosition;
            e.preventDefault();
        });

        document.addEventListener('touchmove', (e) => {
            if (this.isDragging) {
                const delta = Math.floor((this.startY - e.touches[0].clientY) / 30);
                const newPosition = Math.max(0, Math.min(
                    this.positions.length - 1,
                    this.startPosition + delta
                ));

                if (newPosition !== this.currentPosition) {
                    this.currentPosition = newPosition;
                    this.updateDisplay();
                    this.onChange(this.currentPosition);
                }
            }
        });

        document.addEventListener('touchend', () => {
            this.isDragging = false;
        });

        // Click to advance
        this.element.addEventListener('click', (e) => {
            if (!this.isDragging) {
                this.currentPosition = (this.currentPosition + 1) % this.positions.length;
                this.updateDisplay();
                this.onChange(this.currentPosition);
            }
        });
    }

    updateDisplay() {
        // Rotation for 5 positions: -90, -45, 0, 45, 90 degrees
        const anglePerPosition = 180 / (this.positions.length - 1);
        const rotation = (this.currentPosition * anglePerPosition) - 90;
        this.element.style.transform = `rotate(${rotation}deg)`;
        this.labelElement.textContent = this.positions[this.currentPosition];
    }

    setPosition(position) {
        this.currentPosition = Math.max(0, Math.min(this.positions.length - 1, position));
        this.updateDisplay();
    }
}
</file>

<file path="src/ui/Visualizer.js">
// Visualizer.js
// Handles waveform visualization and live signal diagnostics

import { analyseBuffer } from '../utils/signalAnalysis.js';

export class Visualizer {
    constructor(canvasElement, statsElement = null) {
        this.canvas = canvasElement;
        this.ctx = this.canvas.getContext('2d');
        this.isRunning = false;
        this.sampleRate = 44100;

        this.statsElement = statsElement;
        this.statsFields = statsElement ? this._collectStatsFields(statsElement) : null;
        this.statsUpdateInterval = 4;
        this.frameCounter = 0;

        this.resize();
        window.addEventListener('resize', () => this.resize());
    }

    _collectStatsFields(container) {
        const query = (name) => container.querySelector(`[data-stat="${name}"]`);
        return {
            rms: query('rms'),
            peak: query('peak'),
            crest: query('crest'),
            dc: query('dc'),
            p2p: query('p2p')
        };
    }

    resize() {
        const rect = this.canvas.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
    }

    start(getDataFunction) {
        this.isRunning = true;
        this.dataFunction = getDataFunction;
        this.draw();
    }

    stop() {
        this.isRunning = false;
    }

    draw() {
        if (!this.isRunning) return;

        const analyserData = typeof this.dataFunction === 'function'
            ? this.dataFunction()
            : null;

        const timeDomain = this._normaliseTimeDomain(analyserData);
        const frequencyDomain = analyserData && analyserData.frequencyDomain
            ? analyserData.frequencyDomain
            : null;

        if (analyserData && analyserData.sampleRate) {
            this.sampleRate = analyserData.sampleRate;
        }

        this._drawBackground();
        this._drawWaveform(timeDomain);
        this._drawSpectrum(frequencyDomain);
        this._updateStats(timeDomain);

        this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER;
        requestAnimationFrame(() => this.draw());
    }

    _normaliseTimeDomain(data) {
        if (!data) return null;

        if (data.timeDomain instanceof Float32Array) {
            return data.timeDomain;
        }

        const source = Array.isArray(data) || data instanceof Uint8Array ? data : null;
        if (!source) return null;

        const buffer = new Float32Array(source.length);
        for (let i = 0; i < source.length; i++) {
            buffer[i] = (source[i] - 128) / 128; // convert 0-255 to -1..1
        }
        return buffer;
    }

    _drawBackground() {
        this.ctx.fillStyle = '#111';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }

    _drawWaveform(buffer) {
        if (!buffer || buffer.length === 0) {
            return;
        }

        this.ctx.lineWidth = 2;
        this.ctx.strokeStyle = '#4a9eff';
        this.ctx.beginPath();

        const height = this.canvas.height;
        const width = this.canvas.width;
        const waveformHeight = height * 0.65;
        const yOffset = (height - waveformHeight) * 0.5;

        const slice = buffer.length / width;
        let x = 0;

        for (let i = 0; i < width; i++) {
            const sampleIndex = Math.floor(i * slice);
            const sample = buffer[sampleIndex] ?? 0;
            const y = yOffset + (0.5 - sample * 0.5) * waveformHeight;

            if (i === 0) {
                this.ctx.moveTo(x, y);
            } else {
                this.ctx.lineTo(x, y);
            }

            x += 1;
        }

        this.ctx.stroke();
    }

    _drawSpectrum(frequencyDomain) {
        if (!frequencyDomain || frequencyDomain.length === 0) {
            return;
        }

        const height = this.canvas.height;
        const width = this.canvas.width;
        const spectrumHeight = height * 0.25;
        const spectrumTop = height - spectrumHeight - 6;
        const bars = 40;
        const step = Math.floor(frequencyDomain.length / bars);
        const barWidth = width / bars;

        this.ctx.fillStyle = 'rgba(74, 158, 255, 0.2)';
        this.ctx.fillRect(0, spectrumTop, width, spectrumHeight + 6);

        for (let i = 0; i < bars; i++) {
            const index = i * step;
            const value = frequencyDomain[index] ?? 0;
            const magnitude = value / 255;
            const barHeight = magnitude * spectrumHeight;

            const x = i * barWidth;
            const y = spectrumTop + spectrumHeight - barHeight;

            const gradient = this.ctx.createLinearGradient(x, y, x, y + barHeight);
            gradient.addColorStop(0, '#4a9eff');
            gradient.addColorStop(1, '#1a3f70');

            this.ctx.fillStyle = gradient;
            this.ctx.fillRect(x, y, barWidth - 1, Math.max(1, barHeight));
        }
    }

    _updateStats(buffer) {
        if (!this.statsFields || !buffer || buffer.length === 0) {
            return;
        }

        if (this.frameCounter % this.statsUpdateInterval !== 0) {
            return;
        }

        const metrics = analyseBuffer(buffer, this.sampleRate, { includeSpectrum: false });

        if (this.statsFields.rms) {
            this.statsFields.rms.textContent = metrics.rms.toFixed(3);
        }
        if (this.statsFields.peak) {
            this.statsFields.peak.textContent = metrics.peak.toFixed(3);
        }
        if (this.statsFields.p2p) {
            this.statsFields.p2p.textContent = metrics.peakToPeak.toFixed(3);
        }
        if (this.statsFields.crest) {
            this.statsFields.crest.textContent = metrics.crestFactor.toFixed(2);
        }
        if (this.statsFields.dc) {
            this.statsFields.dc.textContent = metrics.dcOffset.toFixed(3);
        }
    }
}
</file>

<file path="src/utils/signalAnalysis.js">
// signalAnalysis.js
// Shared signal analysis utilities for both runtime diagnostics and tests

/**
 * Calculate RMS (Root Mean Square) level
 * @param {Float32Array} buffer - Signal to analyse
 * @param {number} startIndex - Start index (inclusive)
 * @param {number} endIndex - End index (exclusive)
 * @returns {number} RMS level
 */
export function rmsLevel(buffer, startIndex = 0, endIndex = buffer.length) {
    const length = Math.max(1, endIndex - startIndex);
    let sum = 0;
    for (let i = startIndex; i < endIndex; i++) {
        const sample = buffer[i] || 0;
        sum += sample * sample;
    }
    return Math.sqrt(sum / length);
}

/**
 * Calculate peak (maximum absolute) value
 * @param {Float32Array} buffer - Signal to analyse
 * @returns {number} Peak level
 */
export function peakLevel(buffer) {
    let peak = 0;
    for (let i = 0; i < buffer.length; i++) {
        const sample = Math.abs(buffer[i]);
        if (sample > peak) peak = sample;
    }
    return peak;
}

/**
 * Calculate crest factor (peak/RMS)
 * @param {Float32Array} buffer - Signal to analyse
 * @returns {number} Crest factor
 */
export function crestFactor(buffer) {
    const peak = peakLevel(buffer);
    const rms = rmsLevel(buffer);
    return rms > 0 ? peak / rms : 0;
}

/**
 * Calculate mean value (DC offset)
 * @param {Float32Array} buffer - Signal to analyse
 * @returns {number} Mean value
 */
export function mean(buffer) {
    let sum = 0;
    for (let i = 0; i < buffer.length; i++) {
        sum += buffer[i] || 0;
    }
    return sum / buffer.length;
}

/**
 * Detect peak-to-peak amplitude
 * @param {Float32Array} buffer - Signal to analyse
 * @returns {number} Peak-to-peak level
 */
export function peakToPeak(buffer) {
    let min = Infinity;
    let max = -Infinity;
    for (let i = 0; i < buffer.length; i++) {
        const sample = buffer[i];
        if (sample < min) min = sample;
        if (sample > max) max = sample;
    }
    return max - min;
}

/**
 * Compute a simple magnitude spectrum using a windowed FFT
 * Applies a Hann window and zero padding to nearest power of two
 * @param {Float32Array} timeDomain - Time-domain samples
 * @returns {{ frequencies: Float32Array, magnitudes: Float32Array }}
 */
export function computeSpectrum(timeDomain, sampleRate = 44100) {
    const length = timeDomain.length;
    if (length === 0) {
        return { frequencies: new Float32Array(0), magnitudes: new Float32Array(0) };
    }

    const size = Math.pow(2, Math.ceil(Math.log2(length)));
    const real = new Float32Array(size);
    const imag = new Float32Array(size);

    // Apply Hann window and copy into FFT buffer
    for (let i = 0; i < size; i++) {
        const sample = i < length ? timeDomain[i] : 0;
        const window = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (size - 1)));
        real[i] = sample * window;
        imag[i] = 0;
    }

    fft(real, imag);

    const half = size / 2;
    const magnitudes = new Float32Array(half);
    const frequencies = new Float32Array(half);

    for (let i = 0; i < half; i++) {
        const re = real[i];
        const im = imag[i];
        magnitudes[i] = Math.sqrt(re * re + im * im);
        frequencies[i] = (i * sampleRate) / size;
    }

    return { frequencies, magnitudes };
}

/**
 * In-place Cooley-Tukey FFT (radix-2)
 * Adapted for small FFT sizes used in the analyser path
 */
function fft(real, imag) {
    const n = real.length;
    const levels = Math.log2(n);

    if (!Number.isInteger(levels)) {
        throw new Error('FFT size must be a power of two');
    }

    // Bit-reversed addressing permutation
    for (let i = 0; i < n; i++) {
        const j = reverseBits(i, levels);
        if (j > i) {
            [real[i], real[j]] = [real[j], real[i]];
            [imag[i], imag[j]] = [imag[j], imag[i]];
        }
    }

    for (let size = 2; size <= n; size <<= 1) {
        const halfSize = size >> 1;
        const tableStep = (2 * Math.PI) / size;

        for (let i = 0; i < n; i += size) {
            for (let j = 0; j < halfSize; j++) {
                const angle = tableStep * j;
                const cos = Math.cos(angle);
                const sin = -Math.sin(angle);

                const index1 = i + j;
                const index2 = index1 + halfSize;

                const tre = real[index2] * cos - imag[index2] * sin;
                const tim = real[index2] * sin + imag[index2] * cos;

                real[index2] = real[index1] - tre;
                imag[index2] = imag[index1] - tim;
                real[index1] += tre;
                imag[index1] += tim;
            }
        }
    }
}

function reverseBits(value, bits) {
    let reversed = 0;
    for (let i = 0; i < bits; i++) {
        reversed = (reversed << 1) | (value & 1);
        value >>= 1;
    }
    return reversed;
}

/**
 * Convenience helper that aggregates common metrics for display
 * @param {Float32Array} buffer - Time-domain buffer (values in [-1, 1])
 * @param {number} sampleRate - Sample rate for spectral analysis
 * @returns {{
 *   rms: number,
 *   peak: number,
 *   peakToPeak: number,
 *   crestFactor: number,
 *   dcOffset: number,
 *   spectrum: { frequencies: Float32Array, magnitudes: Float32Array }
 * }}
 */
export function analyseBuffer(buffer, sampleRate = 44100, options = {}) {
    const { includeSpectrum = false } = options;
    if (!buffer || buffer.length === 0) {
        return {
            rms: 0,
            peak: 0,
            peakToPeak: 0,
            crestFactor: 0,
            dcOffset: 0,
            spectrum: { frequencies: new Float32Array(0), magnitudes: new Float32Array(0) }
        };
    }

    const result = {
        rms: rmsLevel(buffer),
        peak: peakLevel(buffer),
        peakToPeak: peakToPeak(buffer),
        crestFactor: crestFactor(buffer),
        dcOffset: mean(buffer),
        spectrum: { frequencies: new Float32Array(0), magnitudes: new Float32Array(0) }
    };

    if (includeSpectrum) {
        result.spectrum = computeSpectrum(buffer, sampleRate);
    }

    return result;
}

export const SignalAnalysis = {
    rmsLevel,
    peakLevel,
    crestFactor,
    mean,
    peakToPeak,
    computeSpectrum,
    analyseBuffer
};
</file>

<file path="src/constants.js">
// constants.js
// Shared constants for the Stove

// ============================================================================
// Default Parameter Values (UI range 0-100, normalized 0-1 internally)
// ============================================================================

// Sources
export const DEFAULT_DC_LEVEL = 50;      // 50%
export const DEFAULT_NOISE_LEVEL = 15;   // 15%
export const DEFAULT_TONE_LEVEL = 0;     // 0% (off by default)

// Envelope
export const DEFAULT_ATTACK = 10;        // Fast attack
export const DEFAULT_RELEASE = 50;       // Medium release

// Interface
export const DEFAULT_INTERFACE_TYPE = 2;      // Reed (InterfaceType.REED)
export const DEFAULT_INTERFACE_INTENSITY = 50; // 50%

// Delay Lines
export const DEFAULT_TUNING = 50;        // Center (0 semitones)
export const DEFAULT_RATIO = 50;         // Center (1.0 ratio)

// Feedback
export const DEFAULT_DELAY1_FEEDBACK = 50;  // High feedback
export const DEFAULT_DELAY2_FEEDBACK = 50;  // High feedback
export const DEFAULT_FILTER_FEEDBACK = 0;   // No filter feedback

// Filter
export const DEFAULT_FILTER_FREQUENCY = 70;  // ~7kHz
export const DEFAULT_FILTER_Q = 20;          // Low Q
export const DEFAULT_FILTER_SHAPE = 0;       // Lowpass

// Modulation
export const DEFAULT_LFO_FREQUENCY = 30;         // ~5Hz
export const DEFAULT_MODULATION_TYPE_LEVEL = 50; // Center (no modulation)

// Reverb
export const DEFAULT_REVERB_SIZE = 50;   // Medium room size
export const DEFAULT_REVERB_LEVEL = 30;  // 30% wet mix

// ============================================================================
// Interface Type Names
// ============================================================================

export const INTERFACE_TYPE_NAMES = [
    'Pluck',
    'Hit',
    'Reed',
    'Flute',
    'Brass',
    'Bow',
    'Bell',
    'Drum'
];

// ============================================================================
// Audio Parameters
// ============================================================================

export const DEFAULT_FREQUENCY = 440;  // A4
export const DEFAULT_SAMPLE_RATE = 44100;
</file>

<file path="src/main.js">
// main.js
// Main application initialization and coordination

import { PMSynthProcessor } from './audio/PMSynthProcessor.js';
import { InterfaceType } from './audio/PMSynthEngine.js';
import { KnobController } from './ui/KnobController.js';
import { RotarySwitchController } from './ui/RotarySwitchController.js';
import { KeyboardController } from './ui/KeyboardController.js';
import { MidiController } from './ui/MidiController.js';
import { Visualizer } from './ui/Visualizer.js';
import {
    DEFAULT_DC_LEVEL,
    DEFAULT_NOISE_LEVEL,
    DEFAULT_TONE_LEVEL,
    DEFAULT_ATTACK,
    DEFAULT_RELEASE,
    DEFAULT_INTERFACE_TYPE,
    DEFAULT_INTERFACE_INTENSITY,
    DEFAULT_TUNING,
    DEFAULT_RATIO,
    DEFAULT_DELAY1_FEEDBACK,
    DEFAULT_DELAY2_FEEDBACK,
    DEFAULT_FILTER_FEEDBACK,
    DEFAULT_FILTER_FREQUENCY,
    DEFAULT_FILTER_Q,
    DEFAULT_FILTER_SHAPE,
    DEFAULT_LFO_FREQUENCY,
    DEFAULT_MODULATION_TYPE_LEVEL,
    DEFAULT_REVERB_SIZE,
    DEFAULT_REVERB_LEVEL,
    INTERFACE_TYPE_NAMES
} from './constants.js';

if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js').catch((err) => {
            console.warn('Service worker registration failed', err);
        });
    });
}

let deferredInstallPrompt = null;

function setupInstallPromptUI() {
    const installButton = document.getElementById('install-button');
    if (!installButton) return;

    window.addEventListener('beforeinstallprompt', (event) => {
        event.preventDefault();
        deferredInstallPrompt = event;
        installButton.classList.add('visible');
    });

    installButton.addEventListener('click', async () => {
        if (!deferredInstallPrompt) return;
        try {
            installButton.disabled = true;
            await deferredInstallPrompt.prompt();
            await deferredInstallPrompt.userChoice;
        } catch (err) {
            console.warn('Install prompt failed', err);
        } finally {
            deferredInstallPrompt = null;
            installButton.disabled = false;
            installButton.classList.remove('visible');
        }
    });

    window.addEventListener('appinstalled', () => {
        deferredInstallPrompt = null;
        installButton.classList.remove('visible');
        installButton.disabled = true;
    });
}

setupInstallPromptUI();

class PMSynthApp {
    constructor() {
        this.processor = null;
        this.keyboard = null;
        this.midi = null;
        this.visualizer = null;
        this.knobs = {};
        this.switches = {};
        this.isActive = false;
        this.currentNote = null;

        this.initializeUI();
        this.initializeMidi();
    }

    initializeUI() {
        // Power button
        const powerButton = document.getElementById('power-button');
        if (powerButton) {
            powerButton.addEventListener('click', () => this.togglePower());
        }

        // Initialize Sources knobs
        this.knobs.dcLevel = new KnobController(
            document.getElementById('dc-knob'),
            document.getElementById('dc-value'),
            (value) => this.updateParameter('dcLevel', value),
            0, 100, DEFAULT_DC_LEVEL
        );

        this.knobs.noiseLevel = new KnobController(
            document.getElementById('noise-knob'),
            document.getElementById('noise-value'),
            (value) => this.updateParameter('noiseLevel', value),
            0, 100, DEFAULT_NOISE_LEVEL
        );

        this.knobs.toneLevel = new KnobController(
            document.getElementById('tone-knob'),
            document.getElementById('tone-value'),
            (value) => this.updateParameter('toneLevel', value),
            0, 100, DEFAULT_TONE_LEVEL
        );

        // Initialize Envelope knobs
        this.knobs.attack = new KnobController(
            document.getElementById('attack-knob'),
            document.getElementById('attack-value'),
            (value) => this.updateParameter('attack', value),
            0, 100, DEFAULT_ATTACK
        );

        this.knobs.release = new KnobController(
            document.getElementById('release-knob'),
            document.getElementById('release-value'),
            (value) => this.updateParameter('release', value),
            0, 100, DEFAULT_RELEASE
        );

        // Initialize Interface controls
        this.switches.interfaceType = new RotarySwitchController(
            document.getElementById('interface-type-switch'),
            document.getElementById('interface-type-label'),
            INTERFACE_TYPE_NAMES,
            (position) => this.updateParameter('interfaceType', position),
            DEFAULT_INTERFACE_TYPE
        );

        this.knobs.interfaceIntensity = new KnobController(
            document.getElementById('interface-intensity-knob'),
            document.getElementById('interface-intensity-value'),
            (value) => this.updateParameter('interfaceIntensity', value),
            0, 100, DEFAULT_INTERFACE_INTENSITY
        );

        // Initialize Delay Lines knobs
        this.knobs.tuning = new KnobController(
            document.getElementById('tuning-knob'),
            document.getElementById('tuning-value'),
            (value) => this.updateParameter('tuning', value),
            0, 100, DEFAULT_TUNING
        );

        this.knobs.ratio = new KnobController(
            document.getElementById('ratio-knob'),
            document.getElementById('ratio-value'),
            (value) => this.updateParameter('ratio', value),
            0, 100, DEFAULT_RATIO
        );

        // Initialize Feedback knobs
        this.knobs.delay1Feedback = new KnobController(
            document.getElementById('delay1-fb-knob'),
            document.getElementById('delay1-fb-value'),
            (value) => this.updateParameter('delay1Feedback', value),
            0, 100, DEFAULT_DELAY1_FEEDBACK
        );

        this.knobs.delay2Feedback = new KnobController(
            document.getElementById('delay2-fb-knob'),
            document.getElementById('delay2-fb-value'),
            (value) => this.updateParameter('delay2Feedback', value),
            0, 100, DEFAULT_DELAY2_FEEDBACK
        );

        this.knobs.filterFeedback = new KnobController(
            document.getElementById('filter-fb-knob'),
            document.getElementById('filter-fb-value'),
            (value) => this.updateParameter('filterFeedback', value),
            0, 100, DEFAULT_FILTER_FEEDBACK
        );

        // Initialize Filter knobs
        this.knobs.filterFrequency = new KnobController(
            document.getElementById('filter-freq-knob'),
            document.getElementById('filter-freq-value'),
            (value) => this.updateParameter('filterFrequency', value),
            0, 100, DEFAULT_FILTER_FREQUENCY
        );

        this.knobs.filterQ = new KnobController(
            document.getElementById('filter-q-knob'),
            document.getElementById('filter-q-value'),
            (value) => this.updateParameter('filterQ', value),
            0, 100, DEFAULT_FILTER_Q
        );

        this.knobs.filterShape = new KnobController(
            document.getElementById('filter-shape-knob'),
            document.getElementById('filter-shape-value'),
            (value) => this.updateParameter('filterShape', value),
            0, 100, DEFAULT_FILTER_SHAPE
        );

        // Initialize Modulation knobs
        this.knobs.lfoFrequency = new KnobController(
            document.getElementById('lfo-freq-knob'),
            document.getElementById('lfo-freq-value'),
            (value) => this.updateParameter('lfoFrequency', value),
            0, 100, DEFAULT_LFO_FREQUENCY
        );

        this.knobs.modulationTypeLevel = new KnobController(
            document.getElementById('mod-type-level-knob'),
            document.getElementById('mod-type-level-value'),
            (value) => this.updateParameter('modulationTypeLevel', value),
            0, 100, DEFAULT_MODULATION_TYPE_LEVEL,
            true  // Bipolar mode
        );

        // Initialize Reverb knobs
        this.knobs.reverbSize = new KnobController(
            document.getElementById('reverb-size-knob'),
            document.getElementById('reverb-size-value'),
            (value) => this.updateParameter('reverbSize', value),
            0, 100, DEFAULT_REVERB_SIZE
        );

        this.knobs.reverbLevel = new KnobController(
            document.getElementById('reverb-level-knob'),
            document.getElementById('reverb-level-value'),
            (value) => this.updateParameter('reverbLevel', value),
            0, 100, DEFAULT_REVERB_LEVEL
        );

        // Initialize keyboard
        const keyboardElement = document.getElementById('keyboard');
        if (keyboardElement) {
            this.keyboard = new KeyboardController(
                keyboardElement,
                (note, frequency) => this.handleNoteOn(note, frequency),
                (note) => this.handleNoteOff(note)
            );
        }

        // Initialize visualizer
        const visualizerElement = document.getElementById('visualizer');
        if (visualizerElement) {
            const statsElement = document.getElementById('visualizer-stats');
            this.visualizer = new Visualizer(visualizerElement, statsElement);
        }

        // Update status display
        this.updateStatus();
    }

    async initializeMidi() {
        this.midi = new MidiController(
            (note, frequency, velocity) => this.handleNoteOn(note, frequency),
            (note) => this.handleNoteOff(note)
        );

        const midiAvailable = await this.midi.initialize();

        if (midiAvailable) {
            console.log('[PMSynthApp] MIDI initialized successfully');

            // Set up callbacks for UI updates
            this.midi.onDeviceChange = (devices) => {
                this.updateMidiDeviceList(devices);
            };

            this.midi.onActivity = () => {
                this.showMidiActivity();
            };

            // Initialize MIDI UI
            this.updateMidiDeviceList(this.midi.getInputDevices());
        } else {
            console.log('[PMSynthApp] MIDI not available');
            this.hideMidiPanel();
        }
    }

    updateMidiDeviceList(devices) {
        const select = document.getElementById('midi-device-select');
        if (!select) return;

        // Clear existing options
        select.innerHTML = '<option value="">No device</option>';

        // Add available devices
        devices.forEach(device => {
            const option = document.createElement('option');
            option.value = device.id;
            option.textContent = device.name;
            if (this.midi.selectedInput && this.midi.selectedInput.id === device.id) {
                option.selected = true;
            }
            select.appendChild(option);
        });

        // Update status indicator
        this.updateMidiStatus(devices.length > 0);
    }

    updateMidiStatus(hasDevices) {
        const statusIndicator = document.getElementById('midi-status-indicator');
        const statusText = document.getElementById('midi-status-text');
        if (!statusIndicator || !statusText) return;

        if (!hasDevices) {
            statusIndicator.className = 'midi-status-indicator disconnected';
            statusText.textContent = 'No devices';
        } else if (this.midi.selectedInput) {
            statusIndicator.className = 'midi-status-indicator connected';
            statusText.textContent = 'Connected';
        } else {
            statusIndicator.className = 'midi-status-indicator warning';
            statusText.textContent = 'Select device';
        }
    }

    showMidiActivity() {
        const indicator = document.getElementById('midi-activity-indicator');
        if (!indicator) return;

        indicator.classList.add('active');
        setTimeout(() => {
            indicator.classList.remove('active');
        }, 100);
    }

    hideMidiPanel() {
        const panel = document.getElementById('midi-panel');
        if (panel) {
            panel.style.display = 'none';
        }
    }

    async togglePower() {
        if (!this.isActive) {
            await this.powerOn();
        } else {
            this.powerOff();
        }
    }

    async powerOn() {
        try {
            // Initialize audio processor
            this.processor = new PMSynthProcessor();
            await this.processor.initialize();

            // Apply all current parameter values
            Object.entries(this.knobs).forEach(([key, knob]) => {
                const paramName = this.getParameterName(key);
                this.processor.setParameter(paramName, knob.value / 100);
            });

            // Apply switch positions
            if (this.switches.interfaceType) {
                this.processor.setParameter('interfaceType', this.switches.interfaceType.currentPosition);
            }

            // Start visualizer
            if (this.visualizer) {
                this.visualizer.start(() => this.processor.getAnalyserData());
            }

            this.isActive = true;

            // Update UI
            const powerButton = document.getElementById('power-button');
            if (powerButton) {
                powerButton.classList.add('active');
            }
            this.updateStatus();

            console.log('Stove powered on');
        } catch (error) {
            console.error('Failed to initialize audio:', error);
            alert('Failed to initialize audio. Please check browser compatibility.');
        }
    }

    powerOff() {
        if (this.processor) {
            if (this.keyboard) {
                this.keyboard.releaseAllKeys();
            }
            if (this.midi) {
                this.midi.releaseAllNotes();
            }
            this.processor.shutdown();
            this.processor = null;
        }

        if (this.visualizer) {
            this.visualizer.stop();
        }

        this.isActive = false;
        this.currentNote = null;

        // Update UI
        const powerButton = document.getElementById('power-button');
        if (powerButton) {
            powerButton.classList.remove('active');
        }
        this.updateStatus();

        console.log('Stove powered off');
    }

    handleNoteOn(note, frequency) {
        if (!this.isActive) return;

        this.currentNote = note;
        this.processor.noteOn(frequency);
        this.updateStatus();
    }

    handleNoteOff(note) {
        if (!this.isActive) return;

        if (this.currentNote === note) {
            this.processor.noteOff();
            this.currentNote = null;
            this.updateStatus();
        }
    }

    updateParameter(param, value) {
        if (this.processor && this.processor.isActive) {
            this.processor.setParameter(param, value);
        }
    }

    getParameterName(knobKey) {
        // Map knob keys to parameter names
        const mapping = {
            dcLevel: 'dcLevel',
            noiseLevel: 'noiseLevel',
            toneLevel: 'toneLevel',
            attack: 'attack',
            release: 'release',
            interfaceIntensity: 'interfaceIntensity',
            tuning: 'tuning',
            ratio: 'ratio',
            delay1Feedback: 'delay1Feedback',
            delay2Feedback: 'delay2Feedback',
            filterFeedback: 'filterFeedback',
            filterFrequency: 'filterFrequency',
            filterQ: 'filterQ',
            filterShape: 'filterShape',
            lfoFrequency: 'lfoFrequency',
            modulationTypeLevel: 'modulationTypeLevel',
            reverbSize: 'reverbSize',
            reverbLevel: 'reverbLevel'
        };
        return mapping[knobKey] || knobKey;
    }

    updateStatus() {
        // Status display removed - power button shows active state via CSS
    }
}

// Initialize app when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        window.synthApp = new PMSynthApp();
    });
} else {
    window.synthApp = new PMSynthApp();
}

// Setup MIDI panel event listeners after app initialization
document.addEventListener('DOMContentLoaded', () => {
    const app = window.synthApp;
    if (!app) return;

    // MIDI device selector
    const deviceSelect = document.getElementById('midi-device-select');
    if (deviceSelect) {
        deviceSelect.addEventListener('change', (e) => {
            if (app.midi) {
                app.midi.selectInput(e.target.value);
                app.updateMidiStatus(app.midi.getInputDevices().length > 0);
            }
        });
    }

    // MIDI channel selector
    const channelSelect = document.getElementById('midi-channel-select');
    if (channelSelect) {
        channelSelect.addEventListener('change', (e) => {
            if (app.midi) {
                app.midi.setChannel(e.target.value);
            }
        });
    }

    // MIDI enable toggle
    const enableToggle = document.getElementById('midi-enable-toggle');
    if (enableToggle) {
        enableToggle.addEventListener('change', (e) => {
            if (app.midi) {
                app.midi.setEnabled(e.target.checked);
            }
        });
    }

    // MIDI panic button (all notes off)
    const panicButton = document.getElementById('midi-panic-button');
    if (panicButton) {
        panicButton.addEventListener('click', () => {
            if (app.midi) {
                app.midi.releaseAllNotes();
            }
        });
    }

    // MIDI panel collapse/expand toggle
    const toggleButton = document.getElementById('midi-panel-toggle');
    const panelContent = document.getElementById('midi-panel-content');
    if (toggleButton && panelContent) {
        toggleButton.addEventListener('click', () => {
            panelContent.classList.toggle('collapsed');
            toggleButton.textContent = panelContent.classList.contains('collapsed') ? 'â–¼' : 'â–²';
        });
    }
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    if (window.synthApp) {
        if (window.synthApp.isActive) {
            window.synthApp.powerOff();
        }
        if (window.synthApp.midi) {
            window.synthApp.midi.shutdown();
        }
    }
});
</file>

<file path="test-results/.last-run.json">
{
  "status": "failed",
  "failedTests": []
}
</file>

<file path="tests/unit/modules/DelayLinesModule.test.js">
// DelayLinesModule.test.js
import { describe, it, expect, beforeEach } from 'vitest';
import { DelayLinesModule } from '../../../src/audio/modules/DelayLinesModule.js';
import { TestSignals } from '../../utils/signal-generators.js';
import { SignalAnalysis } from '../../utils/signal-analyzers.js';

describe('DelayLinesModule', () => {
    let delayLines;
    const sampleRate = 44100;

    beforeEach(() => {
        delayLines = new DelayLinesModule(sampleRate);
    });

    describe('Constructor', () => {
        it('should initialize with default values', () => {
            expect(delayLines.sampleRate).toBe(sampleRate);
            expect(delayLines.tuningSemitones).toBe(0);
            expect(delayLines.ratio).toBe(1.0);
            expect(delayLines.frequency).toBe(440);
        });

        it('should create delay line buffers', () => {
            expect(delayLines.delayLine1).toBeInstanceOf(Float32Array);
            expect(delayLines.delayLine2).toBeInstanceOf(Float32Array);
            expect(delayLines.maxDelayLength).toBeGreaterThan(0);
        });
    });

    describe('Parameter setters', () => {
        it('should set tuning in semitones', () => {
            delayLines.setTuning(0.0); // Min
            expect(delayLines.tuningSemitones).toBeCloseTo(-12, 0);

            delayLines.setTuning(0.5); // Center
            expect(delayLines.tuningSemitones).toBeCloseTo(0, 0);

            delayLines.setTuning(1.0); // Max
            expect(delayLines.tuningSemitones).toBeCloseTo(12, 0);
        });

        it('should set ratio', () => {
            delayLines.setRatio(0.0); // Min
            expect(delayLines.ratio).toBeCloseTo(0.5, 1);

            delayLines.setRatio(0.5); // Center
            expect(delayLines.ratio).toBeCloseTo(1.0, 1);

            delayLines.setRatio(1.0); // Max
            expect(delayLines.ratio).toBeCloseTo(2.0, 1);
        });
    });

    describe('Delay length calculation', () => {
        it('should calculate delay length from frequency', () => {
            delayLines.updateDelayLengths(440);

            const expectedLength = sampleRate / 440;
            expect(delayLines.delayLength1).toBeCloseTo(expectedLength, 0);
        });

        it('should apply tuning offset', () => {
            delayLines.setTuning(0.5 + 1/24); // +1 semitone
            delayLines.updateDelayLengths(440);

            const tunedFreq = 440 * Math.pow(2, 1/12);
            const expectedLength = sampleRate / tunedFreq;
            expect(delayLines.delayLength1).toBeCloseTo(expectedLength, 0);
        });

        it('should apply ratio to delay line 2', () => {
            delayLines.setRatio(0.75); // 1.5x ratio
            delayLines.updateDelayLengths(440);

            expect(delayLines.delayLength2).toBeCloseTo(delayLines.delayLength1 * 1.5, 0);
        });
    });

    describe('Process', () => {
        it('should return dual outputs', () => {
            const result = delayLines.process(1.0, 440);

            expect(result).toHaveProperty('delay1');
            expect(result).toHaveProperty('delay2');
        });

        it('should delay the input signal', () => {
            delayLines.updateDelayLengths(440);

            // Write impulse
            delayLines.process(1.0, 440);

            // Should return zeros initially
            for (let i = 0; i < 10; i++) {
                const result = delayLines.process(0.0, 440);
                expect(Math.abs(result.delay1)).toBeLessThan(0.1);
            }
        });

        it('should use linear interpolation', () => {
            // Set frequency that requires fractional delay
            const result = delayLines.process(1.0, 440.5);

            // Should get interpolated values
            expect(isFinite(result.delay1)).toBe(true);
            expect(isFinite(result.delay2)).toBe(true);
        });
    });

    describe('Reset', () => {
        it('should clear delay line buffers', () => {
            // Fill with data
            for (let i = 0; i < 100; i++) {
                delayLines.process(1.0, 440);
            }

            delayLines.reset();

            // Check buffers are cleared (at least first 100 samples)
            for (let i = 0; i < 100; i++) {
                expect(Math.abs(delayLines.delayLine1[i])).toBeLessThan(0.02);
                expect(Math.abs(delayLines.delayLine2[i])).toBeLessThan(0.02);
            }
        });

        it('should reset write positions', () => {
            delayLines.process(1.0, 440);
            delayLines.process(1.0, 440);

            delayLines.reset();

            expect(delayLines.writePos1).toBe(0);
            expect(delayLines.writePos2).toBe(0);
        });
    });

    describe('Signal Behaviour', () => {
        it('should delay an impulse by the expected amount', () => {
            const frequency = 440;
            delayLines.setRatio(0.5); // centre position (ratio â‰ˆ 1.0)
            delayLines.updateDelayLengths(frequency);

            const expectedDelay = delayLines.delayLength1;
            const impulse = TestSignals.impulse(400, 1.0);
            const outputs = new Float32Array(impulse.length);

            for (let i = 0; i < impulse.length; i++) {
                const { delay1 } = delayLines.process(impulse[i], frequency);
                outputs[i] = delay1;
            }

            const peakIndex = outputs.findIndex(sample => Math.abs(sample) > 0.1);
            expect(peakIndex).toBeGreaterThanOrEqual(Math.floor(expectedDelay) - 2);
            expect(peakIndex).toBeLessThanOrEqual(Math.ceil(expectedDelay) + 2);

            for (let i = 0; i < Math.max(0, peakIndex - 5); i++) {
                expect(Math.abs(outputs[i])).toBeLessThan(0.1);
            }

            expect(SignalAnalysis.hasValidOutput(outputs)).toBe(true);
        });

        it('should extend second delay output when ratio increases', () => {
            const frequency = 440;
            delayLines.setRatio(1.0); // Maps to ratio â‰ˆ 2.0
            delayLines.updateDelayLengths(frequency);

            const expectedDelay1 = delayLines.delayLength1;
            const expectedDelay2 = delayLines.delayLength2;

            const impulse = TestSignals.impulse(800, 1.0);
            const outputs1 = new Float32Array(impulse.length);
            const outputs2 = new Float32Array(impulse.length);

            for (let i = 0; i < impulse.length; i++) {
                const { delay1, delay2 } = delayLines.process(impulse[i], frequency);
                outputs1[i] = delay1;
                outputs2[i] = delay2;
            }

            const peak1 = outputs1.findIndex(sample => Math.abs(sample) > 0.1);
            const peak2 = outputs2.findIndex(sample => Math.abs(sample) > 0.1);

            expect(peak1).toBeGreaterThan(0);
            expect(peak2).toBeGreaterThan(peak1);
            expect(peak2).toBeGreaterThanOrEqual(Math.floor(expectedDelay2) - 2);
            expect(peak2).toBeLessThanOrEqual(Math.ceil(expectedDelay2) + 2);

            expect(expectedDelay2).toBeGreaterThan(expectedDelay1);
        });

        it('should remain stable with white noise input', () => {
            const frequency = 220;
            delayLines.setRatio(0.5);
            delayLines.updateDelayLengths(frequency);

            const noise = TestSignals.whiteNoise(2000, 0.5);
            const outputs = new Float32Array(noise.length);

            for (let i = 0; i < noise.length; i++) {
                const { delay1, delay2 } = delayLines.process(noise[i], frequency);
                outputs[i] = (delay1 + delay2) * 0.5;
            }

            expect(SignalAnalysis.hasValidOutput(outputs)).toBe(true);

            // Skip initial transient
            const rms = SignalAnalysis.rmsLevel(outputs, 100, outputs.length);
            expect(rms).toBeGreaterThan(0.001);
            expect(rms).toBeLessThan(1.0);
        });
    });
});
</file>

<file path="tests/unit/modules/EnvelopeModule.test.js">
// EnvelopeModule.test.js
import { describe, it, expect, beforeEach } from 'vitest';
import { EnvelopeModule } from '../../../src/audio/modules/EnvelopeModule.js';
import { TestSignals } from '../../utils/signal-generators.js';
import { SignalAnalysis } from '../../utils/signal-analyzers.js';

describe('EnvelopeModule', () => {
    let envelope;
    const sampleRate = 44100;

    beforeEach(() => {
        envelope = new EnvelopeModule(sampleRate);
    });

    describe('Constructor', () => {
        it('should initialize with default values', () => {
            expect(envelope.sampleRate).toBe(sampleRate);
            expect(envelope.attackTime).toBe(0.01);
            expect(envelope.releaseTime).toBe(0.05);
            expect(envelope.envelope).toBe(0);
            expect(envelope.gate).toBe(false);
            expect(envelope.isActive).toBe(false);
        });
    });

    describe('Parameter setters', () => {
        it('should set attack time with exponential mapping', () => {
            envelope.setAttack(0);
            expect(envelope.attackTime).toBeCloseTo(0.001, 3);

            envelope.setAttack(0.5);
            const midValue = envelope.attackTime;
            expect(midValue).toBeGreaterThan(0.001);
            expect(midValue).toBeLessThan(0.5);

            envelope.setAttack(1);
            expect(envelope.attackTime).toBeCloseTo(0.5, 3);
        });

        it('should set release time with exponential mapping', () => {
            envelope.setRelease(0);
            expect(envelope.releaseTime).toBeCloseTo(0.01, 3);

            envelope.setRelease(1);
            expect(envelope.releaseTime).toBeCloseTo(2.0, 3);
        });
    });

    describe('Gate control', () => {
        it('should respond to gate on', () => {
            envelope.setGate(true);
            expect(envelope.gate).toBe(true);
            expect(envelope.isActive).toBe(true);
        });

        it('should respond to gate off', () => {
            envelope.setGate(true);
            envelope.setGate(false);
            expect(envelope.gate).toBe(false);
        });
    });

    describe('Process - Attack phase', () => {
        it('should rise during attack when gate is on', () => {
            envelope.setAttack(0.5); // 0.1s attack
            envelope.setGate(true);

            const values = [];
            for (let i = 0; i < 100; i++) {
                values.push(envelope.process());
            }

            // Should be rising
            expect(values[10]).toBeGreaterThan(values[0]);
            expect(values[50]).toBeGreaterThan(values[10]);
        });

        it('should reach maximum value of 1.0', () => {
            envelope.setAttack(0.01); // Very fast attack
            envelope.setGate(true);

            let value = 0;
            for (let i = 0; i < 10000; i++) {
                value = envelope.process();
            }

            expect(value).toBe(1.0);
        });
    });

    describe('Process - Release phase', () => {
        it('should fall during release when gate is off', () => {
            envelope.setAttack(0.01);
            envelope.setRelease(0.5);
            envelope.setGate(true);

            // Rise to full
            for (let i = 0; i < 10000; i++) {
                envelope.process();
            }

            envelope.setGate(false);

            const values = [];
            for (let i = 0; i < 100; i++) {
                values.push(envelope.process());
            }

            // Should be falling
            expect(values[10]).toBeLessThan(values[0]);
            expect(values[50]).toBeLessThan(values[10]);
        });

        it('should reach zero and become inactive', () => {
            envelope.setGate(true);
            envelope.process();
            envelope.setGate(false);

            let value = 1;
            for (let i = 0; i < 100000; i++) {
                value = envelope.process();
                if (!envelope.isActive) break;
            }

            expect(value).toBe(0);
            expect(envelope.isActive).toBe(false);
        });
    });

    describe('Reset', () => {
        it('should reset envelope to zero and set active', () => {
            envelope.envelope = 0.5;
            envelope.isActive = false;

            envelope.reset();

            expect(envelope.envelope).toBe(0);
            expect(envelope.isActive).toBe(true);
        });
    });

    describe('isPlaying', () => {
        it('should return active state', () => {
            expect(envelope.isPlaying()).toBe(false);

            envelope.setGate(true);
            expect(envelope.isPlaying()).toBe(true);
        });
    });

    describe('Signal Analysis Tests', () => {
        it('should have smooth attack curve (monotonically increasing)', () => {
            envelope.setAttack(0.1); // 100ms attack
            envelope.setGate(true);

            const attackSamples = Math.floor(0.15 * sampleRate); // Slightly more than attack time
            const output = new Float32Array(attackSamples);

            for (let i = 0; i < attackSamples; i++) {
                output[i] = envelope.process();
            }

            // Check monotonicity - should always increase during attack
            const monotonic = SignalAnalysis.checkMonotonic(output, 'increasing', 0.00001);
            expect(monotonic.monotonic).toBe(true);
            expect(monotonic.violations).toBe(0);
        });

        it('should have smooth release curve (monotonically decreasing)', () => {
            envelope.setAttack(0.001); // Fast attack
            envelope.setRelease(0.1); // 100ms release
            envelope.setGate(true);

            // Rise to full
            for (let i = 0; i < 1000; i++) {
                envelope.process();
            }

            envelope.setGate(false);

            const releaseSamples = Math.floor(0.15 * sampleRate);
            const output = new Float32Array(releaseSamples);

            for (let i = 0; i < releaseSamples; i++) {
                output[i] = envelope.process();
                if (!envelope.isActive) break;
            }

            // Check monotonicity - should always decrease during release
            const monotonic = SignalAnalysis.checkMonotonic(output, 'decreasing', 0.00001);
            expect(monotonic.monotonic).toBe(true);
            expect(monotonic.violations).toBe(0);
        });

        it('should have accurate attack timing (within 5%)', () => {
            envelope.setAttack(0.5); // Maps to 0.001 * sqrt(500) â‰ˆ 0.022s
            envelope.setGate(true);

            // Get the actual attack time that was set
            const expectedAttackTime = envelope.attackTime;

            const output = new Float32Array(sampleRate); // 1 second
            for (let i = 0; i < output.length; i++) {
                output[i] = envelope.process();
            }

            // Find where it reaches 99% of peak (1.0)
            let reachedPeak = -1;
            for (let i = 0; i < output.length; i++) {
                if (output[i] >= 0.99) {
                    reachedPeak = i;
                    break;
                }
            }

            expect(reachedPeak).toBeGreaterThan(0);
            const actualAttackTime = reachedPeak / sampleRate;

            // Should be within 5% of expected attack time
            expect(actualAttackTime).toBeGreaterThan(expectedAttackTime * 0.95);
            expect(actualAttackTime).toBeLessThan(expectedAttackTime * 1.05);
        });

        it('should have accurate release timing (within 10%)', () => {
            const releaseTimeSeconds = 0.1;
            envelope.setAttack(0.001);
            envelope.setRelease(0.5); // This should map to ~0.1-0.2s
            envelope.setGate(true);

            // Rise to full
            for (let i = 0; i < 10000; i++) {
                envelope.process();
            }

            envelope.setGate(false);

            const output = new Float32Array(sampleRate);
            for (let i = 0; i < output.length; i++) {
                output[i] = envelope.process();
                if (!envelope.isActive) break;
            }

            // Measure decay time
            const decay = SignalAnalysis.measureDecayTime(output, 0.01, sampleRate);
            expect(decay.found).toBe(true);

            // Release should complete within reasonable time
            expect(decay.seconds).toBeGreaterThan(0.05);
            expect(decay.seconds).toBeLessThan(0.5);
        });

        it('should never exceed 1.0 or go below 0.0', () => {
            envelope.setAttack(0.01);
            envelope.setRelease(0.05);
            envelope.setGate(true);

            const output = new Float32Array(10000);
            for (let i = 0; i < output.length; i++) {
                output[i] = envelope.process();
                if (i === 5000) envelope.setGate(false); // Release halfway
            }

            // Check bounds
            const peak = SignalAnalysis.peakLevel(output);
            expect(peak).toBeLessThanOrEqual(1.0);

            // Check no negative values
            for (let i = 0; i < output.length; i++) {
                expect(output[i]).toBeGreaterThanOrEqual(0);
            }
        });

        it('should handle rapid gate on/off cycles', () => {
            envelope.setAttack(0.05);
            envelope.setRelease(0.05);

            const output = new Float32Array(10000);
            let gateState = false;

            for (let i = 0; i < output.length; i++) {
                // Toggle gate every 1000 samples
                if (i % 1000 === 0) {
                    gateState = !gateState;
                    envelope.setGate(gateState);
                }
                output[i] = envelope.process();
            }

            // All samples should be valid
            expect(SignalAnalysis.hasValidOutput(output)).toBe(true);

            // Should have activity (not all zeros)
            const rms = SignalAnalysis.rmsLevel(output);
            expect(rms).toBeGreaterThan(0.1);
        });

        it('should have no clicks or discontinuities', () => {
            envelope.setAttack(0.05);
            envelope.setRelease(0.05);
            envelope.setGate(true);

            const output = new Float32Array(sampleRate);
            for (let i = 0; i < output.length; i++) {
                if (i === sampleRate / 2) envelope.setGate(false);
                output[i] = envelope.process();
            }

            // Check for discontinuities
            const discontinuities = SignalAnalysis.detectDiscontinuities(output, 0.1);
            // Envelope should be very smooth, no big jumps
            expect(discontinuities.count).toBe(0);
        });

        it('should complete full attack-release cycle properly', () => {
            envelope.setAttack(0.01);
            envelope.setRelease(0.05);
            envelope.setGate(true);

            // Attack phase
            const attackOutput = new Float32Array(2000);
            for (let i = 0; i < attackOutput.length; i++) {
                attackOutput[i] = envelope.process();
            }

            // Should reach near 1.0
            expect(attackOutput[attackOutput.length - 1]).toBeGreaterThan(0.99);

            // Release phase
            envelope.setGate(false);
            const releaseOutput = new Float32Array(10000);
            for (let i = 0; i < releaseOutput.length; i++) {
                releaseOutput[i] = envelope.process();
                if (!envelope.isActive) break;
            }

            // Should decay to zero
            expect(releaseOutput[releaseOutput.length - 1]).toBe(0);
            expect(envelope.isActive).toBe(false);
        });

        it('should maintain sustain level when gate stays on', () => {
            envelope.setAttack(0.01); // Fast attack
            envelope.setGate(true);

            // Rise to full
            for (let i = 0; i < 2000; i++) {
                envelope.process();
            }

            // Now sustain for a while
            const sustainOutput = new Float32Array(5000);
            for (let i = 0; i < sustainOutput.length; i++) {
                sustainOutput[i] = envelope.process();
            }

            // Should maintain 1.0 throughout
            const mean = SignalAnalysis.mean(sustainOutput);
            expect(mean).toBeCloseTo(1.0, 5);

            const variance = SignalAnalysis.variance(sustainOutput);
            expect(variance).toBeLessThan(0.00001);
        });

        it('should handle extreme parameter values', () => {
            // Very fast attack and release
            envelope.setAttack(0); // Minimum (0.001s)
            envelope.setRelease(0); // Minimum (0.01s)
            envelope.setGate(true);

            const output1 = new Float32Array(1000);
            for (let i = 0; i < output1.length; i++) {
                output1[i] = envelope.process();
            }

            expect(SignalAnalysis.hasValidOutput(output1)).toBe(true);

            // Very slow attack and release
            envelope.reset();
            envelope.setAttack(1); // Maximum (0.5s)
            envelope.setRelease(1); // Maximum (2.0s)
            envelope.setGate(true);

            const output2 = new Float32Array(10000);
            for (let i = 0; i < output2.length; i++) {
                output2[i] = envelope.process();
            }

            expect(SignalAnalysis.hasValidOutput(output2)).toBe(true);
        });
    });
});
</file>

<file path="tests/unit/modules/FeedbackModule.test.js">
// FeedbackModule.test.js
import { describe, it, expect, beforeEach } from 'vitest';
import { FeedbackModule } from '../../../src/audio/modules/FeedbackModule.js';
import { TestSignals } from '../../utils/signal-generators.js';
import { SignalAnalysis } from '../../utils/signal-analyzers.js';

describe('FeedbackModule', () => {
    let feedback;

    beforeEach(() => {
        feedback = new FeedbackModule();
    });

    describe('Constructor', () => {
        it('should initialize with default values', () => {
            expect(feedback.delay1Gain).toBe(0.95);
            expect(feedback.delay2Gain).toBe(0.95);
            expect(feedback.filterGain).toBe(0.0);
        });
    });

    describe('Parameter setters', () => {
        it('should set delay1 gain clamped to 0-0.99', () => {
            feedback.setDelay1Gain(0.8);
            expect(feedback.delay1Gain).toBeCloseTo(0.8 * 0.99, 3);

            feedback.setDelay1Gain(1.0);
            expect(feedback.delay1Gain).toBe(0.99);
        });

        it('should set delay2 gain clamped to 0-0.99', () => {
            feedback.setDelay2Gain(0.5);
            expect(feedback.delay2Gain).toBeCloseTo(0.5 * 0.99, 3);
        });

        it('should set filter gain clamped to 0-0.99', () => {
            feedback.setFilterGain(0.3);
            expect(feedback.filterGain).toBeCloseTo(0.3 * 0.99, 3);
        });
    });

    describe('Process', () => {
        it('should mix all three inputs', () => {
            feedback.setDelay1Gain(0.5);
            feedback.setDelay2Gain(0.5);
            feedback.setFilterGain(0.5);

            const result = feedback.process(1.0, 1.0, 1.0);

            // Should be sum of all three with gains applied
            const expected = (1.0 * 0.5 * 0.99) * 3;
            expect(result).toBeCloseTo(expected, 2);
        });

        it('should handle zero inputs', () => {
            const result = feedback.process(0, 0, 0);
            expect(result).toBe(0);
        });

        it('should apply independent gains', () => {
            feedback.setDelay1Gain(1.0);
            feedback.setDelay2Gain(0.0);
            feedback.setFilterGain(0.0);

            const result = feedback.process(1.0, 1.0, 1.0);

            // Only delay1 should contribute
            expect(result).toBeCloseTo(0.99, 2);
        });
    });

    describe('Reset', () => {
        it('should not throw on reset', () => {
            expect(() => feedback.reset()).not.toThrow();
        });
    });

    describe('Signal Behaviour', () => {
        it('should keep summed feedback bounded with dynamic input', () => {
            feedback.setDelay1Gain(0.9);
            feedback.setDelay2Gain(0.6);
            feedback.setFilterGain(0.3);

            const length = 2048;
            const delay1Signal = TestSignals.whiteNoise(length, 0.6);
            const delay2Signal = TestSignals.whiteNoise(length, 0.6);
            const filterSignal = TestSignals.whiteNoise(length, 0.6);

            const output = new Float32Array(length);
            for (let i = 0; i < length; i++) {
                output[i] = feedback.process(
                    delay1Signal[i],
                    delay2Signal[i],
                    filterSignal[i]
                );
            }

            const maxExpectedGain = feedback.delay1Gain + feedback.delay2Gain + feedback.filterGain;
            expect(SignalAnalysis.hasValidOutput(output, maxExpectedGain + 0.5)).toBe(true);
            const peak = SignalAnalysis.peakLevel(output);
            expect(peak).toBeLessThanOrEqual(maxExpectedGain + 0.2);
        });

        it('should sum constant signals proportionally to gains', () => {
            feedback.setDelay1Gain(0.5);
            feedback.setDelay2Gain(0.25);
            feedback.setFilterGain(0.1);

            const constant = TestSignals.step(0.7, 256);
            const output = new Float32Array(constant.length);

            for (let i = 0; i < constant.length; i++) {
                output[i] = feedback.process(constant[i], constant[i], constant[i]);
            }

            const mean = SignalAnalysis.mean(output);
            const expected = 0.7 * (feedback.delay1Gain + feedback.delay2Gain + feedback.filterGain);
            expect(mean).toBeCloseTo(expected, 4);
        });
    });
});
</file>

<file path="tests/unit/modules/FilterModule.test.js">
// FilterModule.test.js
import { describe, it, expect, beforeEach } from 'vitest';
import { FilterModule } from '../../../src/audio/modules/FilterModule.js';
import { TestSignals } from '../../utils/signal-generators.js';
import { SignalAnalysis } from '../../utils/signal-analyzers.js';

describe('FilterModule', () => {
    let filter;
    const sampleRate = 44100;

    beforeEach(() => {
        filter = new FilterModule(sampleRate);
    });

    describe('Constructor', () => {
        it('should initialize with default values', () => {
            expect(filter.sampleRate).toBe(sampleRate);
            expect(filter.frequency).toBe(1000);
            expect(filter.q).toBe(1.0);
            expect(filter.shape).toBe(0.0);
            expect(filter.low).toBe(0);
            expect(filter.band).toBe(0);
            expect(filter.high).toBe(0);
        });
    });

    describe('Parameter setters', () => {
        it('should set frequency with exponential mapping', () => {
            filter.setFrequency(0);
            expect(filter.frequency).toBeCloseTo(20, 0);

            filter.setFrequency(1);
            expect(filter.frequency).toBeCloseTo(20000, -2);
        });

        it('should set Q with exponential mapping', () => {
            filter.setQ(0);
            expect(filter.q).toBeCloseTo(0.5, 1);

            filter.setQ(1);
            expect(filter.q).toBeCloseTo(20, 0);
        });

        it('should set shape within range', () => {
            filter.setShape(0.5);
            expect(filter.shape).toBe(0.5);

            filter.setShape(1.5);
            expect(filter.shape).toBe(1.0);

            filter.setShape(-0.5);
            expect(filter.shape).toBe(0.0);
        });
    });

    describe('Process', () => {
        it('should output lowpass at shape=0', () => {
            filter.setShape(0.0);
            filter.setFrequency(0.5);

            // Process some samples
            const outputs = [];
            for (let i = 0; i < 100; i++) {
                outputs.push(filter.process(Math.sin(i * 0.1)));
            }

            // Should produce output
            const hasOutput = outputs.some(val => Math.abs(val) > 0.001);
            expect(hasOutput).toBe(true);
        });

        it('should output bandpass at shape=0.5', () => {
            filter.setShape(0.5);
            filter.setFrequency(0.5);

            const outputs = [];
            for (let i = 0; i < 100; i++) {
                outputs.push(filter.process(Math.sin(i * 0.1)));
            }

            const hasOutput = outputs.some(val => Math.abs(val) > 0.001);
            expect(hasOutput).toBe(true);
        });

        it('should output highpass at shape=1.0', () => {
            filter.setShape(1.0);
            filter.setFrequency(0.5);

            const outputs = [];
            for (let i = 0; i < 100; i++) {
                outputs.push(filter.process(Math.sin(i * 0.1)));
            }

            const hasOutput = outputs.some(val => Math.abs(val) > 0.001);
            expect(hasOutput).toBe(true);
        });

        it('should handle NaN/infinity gracefully', () => {
            const output = filter.process(Infinity);
            expect(isFinite(output)).toBe(true);
        });
    });

    describe('Reset', () => {
        it('should reset filter state', () => {
            // Process to build up state
            for (let i = 0; i < 100; i++) {
                filter.process(1.0);
            }

            filter.reset();

            expect(filter.low).toBe(0);
            expect(filter.band).toBe(0);
            expect(filter.high).toBe(0);
        });
    });

    describe('Signal Behaviour', () => {
        const bufferLength = 4096;
        const cutoff = 1000;
        const frequencyValue = Math.log(cutoff / 20) / Math.log(1000);
        const analysisStart = 512;

        it('should attenuate high frequencies in lowpass mode', () => {
            const lowpass = new FilterModule(sampleRate);
            lowpass.setShape(0.0);
            lowpass.setFrequency(frequencyValue);
            lowpass.setQ(0.3);

            const lowSignal = TestSignals.sine(200, sampleRate, bufferLength, 1.0);
            const highSignal = TestSignals.sine(5000, sampleRate, bufferLength, 1.0);

            const lowOutput = new Float32Array(bufferLength);
            const highOutput = new Float32Array(bufferLength);

            for (let i = 0; i < bufferLength; i++) {
                lowOutput[i] = lowpass.process(lowSignal[i]);
            }

            lowpass.reset();
            lowpass.setShape(0.0);
            lowpass.setFrequency(frequencyValue);
            lowpass.setQ(0.3);

            for (let i = 0; i < bufferLength; i++) {
                highOutput[i] = lowpass.process(highSignal[i]);
            }

            const lowRMS = SignalAnalysis.rmsLevel(lowOutput, analysisStart, bufferLength);
            const highRMS = SignalAnalysis.rmsLevel(highOutput, analysisStart, bufferLength);

            expect(lowRMS).toBeGreaterThan(highRMS * 2);
            expect(SignalAnalysis.hasValidOutput(lowOutput)).toBe(true);
            expect(SignalAnalysis.hasValidOutput(highOutput)).toBe(true);
        });

        it('should attenuate low frequencies in highpass mode', () => {
            const highpass = new FilterModule(sampleRate);
            highpass.setShape(1.0);
            highpass.setFrequency(frequencyValue);
            highpass.setQ(0.3);

            const lowSignal = TestSignals.sine(200, sampleRate, bufferLength, 1.0);
            const highSignal = TestSignals.sine(5000, sampleRate, bufferLength, 1.0);

            const lowOutput = new Float32Array(bufferLength);
            const highOutput = new Float32Array(bufferLength);

            for (let i = 0; i < bufferLength; i++) {
                lowOutput[i] = highpass.process(lowSignal[i]);
            }

            highpass.reset();
            highpass.setShape(1.0);
            highpass.setFrequency(frequencyValue);
            highpass.setQ(0.3);

            for (let i = 0; i < bufferLength; i++) {
                highOutput[i] = highpass.process(highSignal[i]);
            }

            const lowRMS = SignalAnalysis.rmsLevel(lowOutput, analysisStart, bufferLength);
            const highRMS = SignalAnalysis.rmsLevel(highOutput, analysisStart, bufferLength);

            expect(highRMS).toBeGreaterThan(lowRMS * 2);
            expect(SignalAnalysis.hasValidOutput(lowOutput)).toBe(true);
            expect(SignalAnalysis.hasValidOutput(highOutput)).toBe(true);
        });

        it('should emphasise centre frequency in bandpass mode', () => {
            const bandpass = new FilterModule(sampleRate);
            bandpass.setShape(0.5);
            bandpass.setFrequency(frequencyValue);
            bandpass.setQ(0.6); // narrower band for clarity

            const centreSignal = TestSignals.sine(cutoff, sampleRate, bufferLength, 1.0);
            const lowSignal = TestSignals.sine(200, sampleRate, bufferLength, 1.0);
            const highSignal = TestSignals.sine(5000, sampleRate, bufferLength, 1.0);

            const centreOutput = new Float32Array(bufferLength);
            const lowOutput = new Float32Array(bufferLength);
            const highOutput = new Float32Array(bufferLength);

            for (let i = 0; i < bufferLength; i++) {
                centreOutput[i] = bandpass.process(centreSignal[i]);
            }

            bandpass.reset();
            bandpass.setShape(0.5);
            bandpass.setFrequency(frequencyValue);
            bandpass.setQ(0.6);

            for (let i = 0; i < bufferLength; i++) {
                lowOutput[i] = bandpass.process(lowSignal[i]);
            }

            bandpass.reset();
            bandpass.setShape(0.5);
            bandpass.setFrequency(frequencyValue);
            bandpass.setQ(0.6);

            for (let i = 0; i < bufferLength; i++) {
                highOutput[i] = bandpass.process(highSignal[i]);
            }

            const centreRMS = SignalAnalysis.rmsLevel(centreOutput, analysisStart, bufferLength);
            const lowRMS = SignalAnalysis.rmsLevel(lowOutput, analysisStart, bufferLength);
            const highRMS = SignalAnalysis.rmsLevel(highOutput, analysisStart, bufferLength);

            expect(centreRMS).toBeGreaterThan(lowRMS * 1.5);
            expect(centreRMS).toBeGreaterThan(highRMS * 1.5);
            expect(SignalAnalysis.hasValidOutput(centreOutput)).toBe(true);
            expect(SignalAnalysis.hasValidOutput(lowOutput)).toBe(true);
            expect(SignalAnalysis.hasValidOutput(highOutput)).toBe(true);
        });

        it('should remain numerically stable with noise input', () => {
            const filterUnderTest = new FilterModule(sampleRate);
            filterUnderTest.setShape(0.25);
            filterUnderTest.setFrequency(0.7);
            filterUnderTest.setQ(0.4);

            const noise = TestSignals.whiteNoise(bufferLength, 0.5);
            const output = new Float32Array(bufferLength);

            for (let i = 0; i < bufferLength; i++) {
                output[i] = filterUnderTest.process(noise[i]);
            }

            expect(SignalAnalysis.hasValidOutput(output)).toBe(true);
            const rms = SignalAnalysis.rmsLevel(output, analysisStart, bufferLength);
            expect(rms).toBeGreaterThan(0.001);
        });
    });
});
</file>

<file path="tests/unit/modules/InterfaceModule.test.js">
// InterfaceModule.test.js
import { describe, it, expect, beforeEach } from 'vitest';
import { InterfaceModule, InterfaceType } from '../../../src/audio/modules/InterfaceModule.js';
import { TestSignals } from '../../utils/signal-generators.js';
import { SignalAnalysis } from '../../utils/signal-analyzers.js';

describe('InterfaceModule', () => {
    let interface_;

    beforeEach(() => {
        interface_ = new InterfaceModule();
    });

    describe('Constructor', () => {
        it('should initialize with default values', () => {
            expect(interface_.type).toBe(InterfaceType.REED);
            expect(interface_.intensity).toBe(0.5);
        });
    });

    describe('Parameter setters', () => {
        it('should set interface type', () => {
            interface_.setType(InterfaceType.PLUCK);
            expect(interface_.type).toBe(InterfaceType.PLUCK);

            interface_.setType(InterfaceType.BRASS);
            expect(interface_.type).toBe(InterfaceType.BRASS);
        });

        it('should clamp intensity to 0-1 range', () => {
            interface_.setIntensity(0.8);
            expect(interface_.intensity).toBe(0.8);

            interface_.setIntensity(1.5);
            expect(interface_.intensity).toBe(1.0);

            interface_.setIntensity(-0.5);
            expect(interface_.intensity).toBe(0.0);
        });
    });

    describe('Fast tanh approximation', () => {
        it('should clip at threshold', () => {
            expect(interface_.fastTanh(10)).toBe(1);
            expect(interface_.fastTanh(-10)).toBe(-1);
        });

        it('should approximate tanh for small values', () => {
            const result = interface_.fastTanh(0.5);
            expect(result).toBeGreaterThan(0);
            expect(result).toBeLessThan(1);
        });

        it('should be zero at zero', () => {
            expect(interface_.fastTanh(0)).toBe(0);
        });
    });

    describe('Pluck interface', () => {
        beforeEach(() => {
            interface_.setType(InterfaceType.PLUCK);
        });

        it('should pass initial impulse', () => {
            const input = 0.5;
            const output = interface_.process(input);
            expect(output).toBe(input);
        });

        it('should dampen subsequent signals', () => {
            interface_.setIntensity(0.5);
            interface_.process(1.0); // Initial peak

            const output = interface_.process(0.5);
            expect(output).toBeLessThan(0.5);
        });
    });

    describe('Hit interface', () => {
        beforeEach(() => {
            interface_.setType(InterfaceType.HIT);
        });

        it('should apply hard waveshaping', () => {
            interface_.setIntensity(0.8);
            const output = interface_.process(0.5);
            expect(Math.abs(output)).toBeLessThanOrEqual(1.0);
        });
    });

    describe('Reed interface', () => {
        beforeEach(() => {
            interface_.setType(InterfaceType.REED);
        });

        it('should apply nonlinear transfer', () => {
            interface_.setIntensity(0.5);

            const output1 = interface_.process(0.1);
            const output2 = interface_.process(0.2);

            // Should be nonlinear (not simply 2x)
            expect(output2 / output1).not.toBeCloseTo(2.0, 1);
        });

        it('should saturate at high inputs', () => {
            interface_.setIntensity(0.5);
            const output = interface_.process(10.0);
            expect(Math.abs(output)).toBeLessThanOrEqual(1.0);
        });
    });

    describe('Flute interface', () => {
        beforeEach(() => {
            interface_.setType(InterfaceType.FLUTE);
        });

        it('should apply soft saturation', () => {
            interface_.setIntensity(0.5);
            const output = interface_.process(0.5);
            expect(Math.abs(output)).toBeLessThan(0.5);
        });
    });

    describe('Brass interface', () => {
        beforeEach(() => {
            interface_.setType(InterfaceType.BRASS);
        });

        it('should have asymmetric response', () => {
            interface_.setIntensity(0.5);

            const outputPos = interface_.process(0.5);
            const outputNeg = interface_.process(-0.5);

            expect(Math.abs(outputPos)).not.toBeCloseTo(Math.abs(outputNeg), 1);
            expect(Math.abs(outputPos)).toBeLessThanOrEqual(1);
            expect(Math.abs(outputNeg)).toBeLessThanOrEqual(1);
        });
    });

    describe('Bow interface', () => {
        beforeEach(() => {
            interface_.setType(InterfaceType.BOW);
        });

        it('should respond smoothly to continuous input', () => {
            interface_.setIntensity(0.5);
            const sine = TestSignals.sine(10, 44100, 512, 0.5);
            const output = new Float32Array(sine.length);
            for (let i = 0; i < sine.length; i++) {
                output[i] = interface_.process(sine[i]);
            }
            expect(SignalAnalysis.hasValidOutput(output, 1)).toBe(true);
            const variance = SignalAnalysis.variance(output);
            expect(variance).toBeGreaterThan(0.01);
        });
    });

    describe('Bell interface', () => {
        beforeEach(() => {
            interface_.setType(InterfaceType.BELL);
        });

        it('should introduce metallic overtones', () => {
            interface_.setIntensity(0.7);
            const burst = TestSignals.impulse(256, 0.8);
            const output = new Float32Array(burst.length);
            for (let i = 0; i < burst.length; i++) {
                output[i] = interface_.process(burst[i]);
            }
            expect(SignalAnalysis.hasValidOutput(output, 1)).toBe(true);
            const crest = SignalAnalysis.crestFactor(output);
            expect(crest).toBeGreaterThan(1.2);
        });
    });

    describe('Drum interface', () => {
        beforeEach(() => {
            interface_.setType(InterfaceType.DRUM);
        });

        it('should build energy with loud hits', () => {
            interface_.setIntensity(0.8);
            const hits = TestSignals.square(60, 44100, 512, 0.6);
            const output = new Float32Array(hits.length);
            for (let i = 0; i < hits.length; i++) {
                output[i] = interface_.process(hits[i]);
            }
            expect(SignalAnalysis.hasValidOutput(output, 1.5)).toBe(true);
            const rms = SignalAnalysis.rmsLevel(output);
            expect(rms).toBeGreaterThan(0.2);
        });
    });

    describe('Reset', () => {
        it('should reset pluck state', () => {
            interface_.setType(InterfaceType.PLUCK);
            interface_.process(1.0);
            expect(interface_.lastPeak).not.toBe(0);

            interface_.reset();
            expect(interface_.lastPeak).toBe(0);
        });
    });

    describe('Signal Behaviour', () => {
        it('should dampen sustained energy in pluck mode after the initial strike', () => {
            const module = new InterfaceModule();
            module.setType(InterfaceType.PLUCK);
            module.setIntensity(1.0);

            const impulse = TestSignals.impulse(128, 1.0);
            const output = new Float32Array(impulse.length);

            for (let i = 0; i < impulse.length; i++) {
                output[i] = module.process(impulse[i]);
            }

            const firstSample = Math.abs(output[0]);
            let maxAfter = 0;
            for (let i = 1; i < output.length; i++) {
                const value = Math.abs(output[i]);
                if (value > maxAfter) maxAfter = value;
            }

            expect(firstSample).toBeGreaterThan(0);
            expect(maxAfter).toBeLessThan(firstSample * 0.7);
        });

        it('should keep hit output bounded under heavy excitation', () => {
            const module = new InterfaceModule();
            module.setType(InterfaceType.HIT);
            module.setIntensity(1.0);

            const noise = TestSignals.whiteNoise(2000, 1.0);
            const output = new Float32Array(noise.length);

            for (let i = 0; i < noise.length; i++) {
                output[i] = module.process(noise[i]);
            }

            expect(SignalAnalysis.hasValidOutput(output, 1.2)).toBe(true);
            const peak = SignalAnalysis.peakLevel(output);
            expect(peak).toBeLessThanOrEqual(1.0);
        });

        it('should increase output level with reed intensity', () => {
            const module = new InterfaceModule();
            module.setType(InterfaceType.REED);

            module.setIntensity(0.1);
            const lowIntensity = module.process(0.5);

            module.setIntensity(0.9);
            const highIntensity = module.process(0.5);

            expect(Math.abs(highIntensity)).toBeGreaterThan(Math.abs(lowIntensity));
            expect(Math.abs(highIntensity)).toBeLessThanOrEqual(1.0);
        });

        it('should softly saturate in flute mode', () => {
            const module = new InterfaceModule();
            module.setType(InterfaceType.FLUTE);
            module.setIntensity(1.0);

            const sine = TestSignals.sine(440, 44100, 512, 0.8);
            const output = new Float32Array(sine.length);

            for (let i = 0; i < sine.length; i++) {
                output[i] = module.process(sine[i]);
            }

            const peak = SignalAnalysis.peakLevel(output);
            expect(peak).toBeLessThan(0.8);
            expect(SignalAnalysis.hasValidOutput(output, 1.0)).toBe(true);
        });

        it('should introduce asymmetry in brass mode over time', () => {
            const module = new InterfaceModule();
            module.setType(InterfaceType.BRASS);
            module.setIntensity(1.0);

            const sine = TestSignals.sine(220, 44100, 2048, 0.7);
            const output = new Float32Array(sine.length);

            for (let i = 0; i < sine.length; i++) {
                output[i] = module.process(sine[i]);
            }

            const mean = SignalAnalysis.mean(output);
            expect(Math.abs(mean)).toBeGreaterThan(0.01);
        });
    });
});
</file>

<file path="tests/unit/modules/ModulationModule.test.js">
// ModulationModule.test.js
import { describe, it, expect, beforeEach } from 'vitest';
import { ModulationModule } from '../../../src/audio/modules/ModulationModule.js';
import { SignalAnalysis } from '../../utils/signal-analyzers.js';

describe('ModulationModule', () => {
    let modulation;
    const sampleRate = 44100;

    beforeEach(() => {
        modulation = new ModulationModule(sampleRate);
    });

    describe('Constructor', () => {
        it('should initialize with default values', () => {
            expect(modulation.sampleRate).toBe(sampleRate);
            expect(modulation.lfoFrequency).toBe(5);
            expect(modulation.lfoPhase).toBe(0);
            expect(modulation.typeLevel).toBe(0.5);
            expect(modulation.amDepth).toBe(0);
            expect(modulation.fmDepth).toBe(0);
        });
    });

    describe('Parameter setters', () => {
        it('should set LFO frequency with exponential mapping', () => {
            modulation.setFrequency(0);
            expect(modulation.lfoFrequency).toBeCloseTo(0.1, 1);

            modulation.setFrequency(1);
            expect(modulation.lfoFrequency).toBeCloseTo(20, 0);
        });

        it('should set AM mode when typeLevel < 0.5', () => {
            modulation.setTypeLevel(0.25);
            expect(modulation.typeLevel).toBe(0.25);
            expect(modulation.amDepth).toBeGreaterThan(0);
            expect(modulation.fmDepth).toBe(0);
        });

        it('should set FM mode when typeLevel > 0.5', () => {
            modulation.setTypeLevel(0.75);
            expect(modulation.typeLevel).toBe(0.75);
            expect(modulation.amDepth).toBe(0);
            expect(modulation.fmDepth).toBeGreaterThan(0);
        });

        it('should have no modulation at typeLevel = 0.5', () => {
            modulation.setTypeLevel(0.5);
            expect(modulation.amDepth).toBe(0);
            expect(modulation.fmDepth).toBe(0);
        });
    });

    describe('Process', () => {
        it('should generate LFO between -1 and 1', () => {
            const outputs = [];
            for (let i = 0; i < 1000; i++) {
                const result = modulation.process();
                outputs.push(result.lfo);
            }

            const max = Math.max(...outputs);
            const min = Math.min(...outputs);

            expect(max).toBeLessThanOrEqual(1);
            expect(min).toBeGreaterThanOrEqual(-1);
        });

        it('should generate AM multiplier around 1', () => {
            modulation.setTypeLevel(0.0); // Max AM

            const outputs = [];
            for (let i = 0; i < 1000; i++) {
                const result = modulation.process();
                outputs.push(result.am);
            }

            const max = Math.max(...outputs);
            const min = Math.min(...outputs);

            // AM should vary around 1
            expect(max).toBeLessThanOrEqual(1.5);
            expect(min).toBeGreaterThanOrEqual(0);
        });

        it('should generate FM multiplier around 1', () => {
            modulation.setTypeLevel(1.0); // Max FM

            const outputs = [];
            for (let i = 0; i < 1000; i++) {
                const result = modulation.process();
                outputs.push(result.fm);
            }

            const max = Math.max(...outputs);
            const min = Math.min(...outputs);

            // FM should vary around 1 by Â±10%
            expect(max).toBeLessThanOrEqual(1.1);
            expect(min).toBeGreaterThanOrEqual(0.9);
        });

        it('should advance LFO phase', () => {
            expect(modulation.lfoPhase).toBe(0);

            modulation.process();
            const phase1 = modulation.lfoPhase;
            expect(phase1).toBeGreaterThan(0);

            modulation.process();
            const phase2 = modulation.lfoPhase;
            expect(phase2).toBeGreaterThan(phase1);
        });

        it('should wrap phase at 2Ï€', () => {
            modulation.lfoPhase = 2 * Math.PI - 0.001;

            modulation.process();
            modulation.process();

            expect(modulation.lfoPhase).toBeLessThan(2 * Math.PI);
        });
    });

    describe('Reset', () => {
        it('should reset LFO phase to zero', () => {
            modulation.process();
            modulation.process();
            expect(modulation.lfoPhase).toBeGreaterThan(0);

            modulation.reset();
            expect(modulation.lfoPhase).toBe(0);
        });
    });

    describe('Signal Behaviour', () => {
        it('should generate LFO at the configured frequency', () => {
            const targetFrequency = 7.5;
            const value = Math.log(targetFrequency / 0.1) / Math.log(200);

            modulation.setFrequency(value);
            modulation.setTypeLevel(0.5); // No AM/FM modulation

            const length = sampleRate * 2; // 2 seconds for accuracy
            const lfoBuffer = new Float32Array(length);

            for (let i = 0; i < length; i++) {
                const { lfo } = modulation.process();
                lfoBuffer[i] = lfo;
            }

            const estimated = SignalAnalysis.estimateFrequency(lfoBuffer, sampleRate);
            expect(estimated).toBeGreaterThan(targetFrequency * 0.9);
            expect(estimated).toBeLessThan(targetFrequency * 1.1);
        });

        it('should leave FM multiplier neutral when in AM mode', () => {
            modulation.setTypeLevel(0.25); // AM engaged

            let maxDeviation = 0;
            for (let i = 0; i < 2000; i++) {
                const { fm } = modulation.process();
                const deviation = Math.abs(fm - 1);
                if (deviation > maxDeviation) maxDeviation = deviation;
            }

            expect(maxDeviation).toBeLessThan(0.001);
        });

        it('should leave AM multiplier neutral when in FM mode', () => {
            modulation.setTypeLevel(0.75); // FM engaged

            let maxDeviation = 0;
            for (let i = 0; i < 2000; i++) {
                const { am } = modulation.process();
                const deviation = Math.abs(am - 1);
                if (deviation > maxDeviation) maxDeviation = deviation;
            }

            expect(maxDeviation).toBeLessThan(0.001);
        });
    });
});
</file>

<file path="tests/unit/modules/ReverbModule.test.js">
// ReverbModule.test.js
import { describe, it, expect, beforeEach } from 'vitest';
import { ReverbModule } from '../../../src/audio/modules/ReverbModule.js';
import { TestSignals } from '../../utils/signal-generators.js';
import { SignalAnalysis } from '../../utils/signal-analyzers.js';

describe('ReverbModule', () => {
    let reverb;
    const sampleRate = 44100;

    beforeEach(() => {
        reverb = new ReverbModule(sampleRate);
    });

    describe('Constructor', () => {
        it('should initialize with default values', () => {
            expect(reverb.sampleRate).toBe(sampleRate);
            expect(reverb.size).toBe(0.5);
            expect(reverb.level).toBe(0.3);
        });

        it('should create comb filter buffers', () => {
            expect(reverb.combBuffers).toHaveLength(4);
            reverb.combBuffers.forEach(buffer => {
                expect(buffer).toBeInstanceOf(Float32Array);
                expect(buffer.length).toBeGreaterThan(0);
            });
        });

        it('should create allpass filter buffers', () => {
            expect(reverb.allpassBuffers).toHaveLength(2);
            reverb.allpassBuffers.forEach(buffer => {
                expect(buffer).toBeInstanceOf(Float32Array);
                expect(buffer.length).toBeGreaterThan(0);
            });
        });
    });

    describe('Parameter setters', () => {
        it('should set size with clamping', () => {
            reverb.setSize(0.7);
            expect(reverb.size).toBe(0.7);

            reverb.setSize(1.5);
            expect(reverb.size).toBe(1.0);

            reverb.setSize(-0.1);
            expect(reverb.size).toBe(0);
        });

        it('should set level with clamping', () => {
            reverb.setLevel(0.5);
            expect(reverb.level).toBe(0.5);

            reverb.setLevel(1.5);
            expect(reverb.level).toBe(1.0);

            reverb.setLevel(-0.1);
            expect(reverb.level).toBe(0);
        });
    });

    describe('Process', () => {
        it('should return a number', () => {
            const result = reverb.process(1.0);
            expect(typeof result).toBe('number');
            expect(isFinite(result)).toBe(true);
        });

        it('should pass through dry signal when level is 0', () => {
            reverb.setLevel(0);
            const input = 0.5;
            const result = reverb.process(input);
            expect(result).toBeCloseTo(input, 5);
        });

        it('should process signal with reverb level applied', () => {
            reverb.setLevel(1.0);

            const input = 0.5;
            const result = reverb.process(input);

            // With 100% wet, output should differ from dry input
            expect(result).not.toBeCloseTo(input, 5);
            expect(isFinite(result)).toBe(true);
        });

        it('should handle continuous input', () => {
            reverb.setLevel(0.5);
            reverb.setSize(0.7);

            for (let i = 0; i < 1000; i++) {
                const input = Math.sin(i * 0.1);
                const output = reverb.process(input);
                expect(isFinite(output)).toBe(true);
                expect(Math.abs(output)).toBeLessThan(10);
            }
        });
    });

    describe('Reset', () => {
        it('should clear all comb filter buffers', () => {
            for (let i = 0; i < 500; i++) {
                reverb.process(Math.random());
            }

            reverb.reset();

            reverb.combBuffers.forEach(buffer => {
                const sum = buffer.reduce((a, b) => a + Math.abs(b), 0);
                expect(sum).toBe(0);
            });
        });

        it('should clear all allpass filter buffers', () => {
            for (let i = 0; i < 500; i++) {
                reverb.process(Math.random());
            }

            reverb.reset();

            reverb.allpassBuffers.forEach(buffer => {
                const sum = buffer.reduce((a, b) => a + Math.abs(b), 0);
                expect(sum).toBe(0);
            });
        });

        it('should produce silence after reset', () => {
            for (let i = 0; i < 500; i++) {
                reverb.process(Math.random());
            }

            reverb.reset();

            const outputs = [];
            for (let i = 0; i < 100; i++) {
                outputs.push(reverb.process(0));
            }

            outputs.forEach(output => {
                expect(Math.abs(output)).toBeLessThan(0.001);
            });
        });
    });

    describe('Signal Behaviour', () => {
        it('should produce a decaying impulse response', () => {
            reverb.setLevel(1.0);
            reverb.setSize(0.5);

            const length = 8000;
            const output = new Float32Array(length);

            for (let i = 0; i < length; i++) {
                const input = i === 0 ? 1.0 : 0.0;
                output[i] = reverb.process(input);
            }

            expect(SignalAnalysis.hasValidOutput(output)).toBe(true);

            const peak = SignalAnalysis.peakLevel(output);
            const buildRMS = SignalAnalysis.rmsLevel(output, 500, 1500);
            const sustainRMS = SignalAnalysis.rmsLevel(output, 2500, 3500);
            const decayRMS = SignalAnalysis.rmsLevel(output, 4500, 5500);

            expect(peak).toBeGreaterThan(0.001);
            expect(buildRMS).toBeGreaterThan(0.0001);
            expect(sustainRMS).toBeGreaterThan(0.0001);
            expect(decayRMS).toBeLessThan(sustainRMS);
        });

        it('should extend decay time as size increases', () => {
            const length = 10000;
            reverb.setLevel(1.0);

            reverb.setSize(0.2);
            reverb.reset();
            const shortOutput = new Float32Array(length);
            for (let i = 0; i < length; i++) {
                const input = i === 0 ? 1.0 : 0.0;
                shortOutput[i] = reverb.process(input);
            }
            const shortTail = SignalAnalysis.rmsLevel(shortOutput, 4000, 5000);

            reverb.setSize(0.9);
            reverb.reset();
            const longOutput = new Float32Array(length);
            for (let i = 0; i < length; i++) {
                const input = i === 0 ? 1.0 : 0.0;
                longOutput[i] = reverb.process(input);
            }
            const longTail = SignalAnalysis.rmsLevel(longOutput, 4000, 5000);

            expect(longTail).toBeGreaterThan(shortTail);
        });

        it('should honour the wet/dry mix level', () => {
            const signal = TestSignals.sine(440, sampleRate, 4096, 0.5);
            const analysisStart = 256;

            reverb.setSize(0.6);

            reverb.reset();
            reverb.setLevel(0.0);
            const dryOutput = new Float32Array(signal.length);
            for (let i = 0; i < signal.length; i++) {
                dryOutput[i] = reverb.process(signal[i]);
            }

            reverb.reset();
            reverb.setLevel(1.0);
            const wetOutput = new Float32Array(signal.length);
            for (let i = 0; i < signal.length; i++) {
                wetOutput[i] = reverb.process(signal[i]);
            }

            reverb.reset();
            reverb.setLevel(0.5);
            const mixedOutput = new Float32Array(signal.length);
            for (let i = 0; i < signal.length; i++) {
                mixedOutput[i] = reverb.process(signal[i]);
            }

            for (let i = analysisStart; i < mixedOutput.length; i++) {
                const expectedSample = signal[i] * 0.5 + wetOutput[i] * 0.5;
                expect(Math.abs(mixedOutput[i] - expectedSample)).toBeLessThan(0.001);
            }
        });
    });
});
</file>

<file path="tests/unit/modules/SourcesModule.test.js">
// SourcesModule.test.js
import { describe, it, expect, beforeEach } from 'vitest';
import { SourcesModule } from '../../../src/audio/modules/SourcesModule.js';
import { TestSignals } from '../../utils/signal-generators.js';
import { SignalAnalysis } from '../../utils/signal-analyzers.js';
import { TestHelpers } from '../../utils/test-helpers.js';

describe('SourcesModule', () => {
    let sources;
    const sampleRate = 44100;

    beforeEach(() => {
        sources = new SourcesModule(sampleRate);
    });

    describe('Constructor', () => {
        it('should initialize with default values', () => {
            expect(sources.sampleRate).toBe(sampleRate);
            expect(sources.dcLevel).toBe(0.5);
            expect(sources.noiseLevel).toBe(0.15);
            expect(sources.toneLevel).toBe(0.0);
            expect(sources.sawtoothPhase).toBe(0);
        });
    });

    describe('Parameter setters', () => {
        it('should set DC level within range', () => {
            sources.setDCLevel(0.8);
            expect(sources.dcLevel).toBe(0.8);

            sources.setDCLevel(1.5); // Over max
            expect(sources.dcLevel).toBe(1.0);

            sources.setDCLevel(-0.5); // Under min
            expect(sources.dcLevel).toBe(0.0);
        });

        it('should set noise level within range', () => {
            sources.setNoiseLevel(0.3);
            expect(sources.noiseLevel).toBe(0.3);
        });

        it('should set tone level within range', () => {
            sources.setToneLevel(0.5);
            expect(sources.toneLevel).toBe(0.5);
        });
    });

    describe('Process', () => {
        it('should generate DC component', () => {
            sources.setDCLevel(0.5);
            sources.setNoiseLevel(0);
            sources.setToneLevel(0);

            const output = sources.process(440);
            expect(output).toBeCloseTo(0.5, 10);
        });

        it('should generate output with noise', () => {
            sources.setDCLevel(0);
            sources.setNoiseLevel(0.5);
            sources.setToneLevel(0);

            const outputs = [];
            for (let i = 0; i < 100; i++) {
                outputs.push(sources.process(440));
            }

            // Noise should vary
            const variance = outputs.reduce((sum, val) => sum + val * val, 0) / outputs.length;
            expect(variance).toBeGreaterThan(0);
        });

        it('should generate sawtooth tone', () => {
            sources.setDCLevel(0);
            sources.setNoiseLevel(0);
            sources.setToneLevel(1.0);

            const output1 = sources.process(440);
            const output2 = sources.process(440);

            // Sawtooth should be different values (phase advancing)
            expect(output1).not.toBe(output2);
        });

        it('should sum all sources', () => {
            sources.setDCLevel(0.3);
            sources.setNoiseLevel(0.0);
            sources.setToneLevel(0.0);

            const output = sources.process(440);
            expect(Math.abs(output - 0.3)).toBeLessThan(0.1); // Should be close to DC value
        });
    });

    describe('Reset', () => {
        it('should reset sawtooth phase to zero', () => {
            sources.process(440);
            sources.process(440);
            expect(sources.sawtoothPhase).toBeGreaterThan(0);

            sources.reset();
            expect(sources.sawtoothPhase).toBe(0);
        });
    });

    describe('Signal Analysis Tests', () => {
        it('should produce stable DC output over extended duration', () => {
            sources.setDCLevel(0.5);
            sources.setNoiseLevel(0);
            sources.setToneLevel(0);

            const output = new Float32Array(10000);
            for (let i = 0; i < output.length; i++) {
                output[i] = sources.process(440);
            }

            // Check mean is close to expected DC level
            const mean = SignalAnalysis.mean(output);
            expect(mean).toBeCloseTo(0.5, 5);

            // Variance should be essentially zero (no drift)
            const variance = SignalAnalysis.variance(output);
            expect(variance).toBeLessThan(0.000001);
        });

        it('should produce noise with approximately zero mean', () => {
            sources.setDCLevel(0);
            sources.setNoiseLevel(1.0);
            sources.setToneLevel(0);

            const output = new Float32Array(10000);
            for (let i = 0; i < output.length; i++) {
                output[i] = sources.process(440);
            }

            // Mean should be close to zero (no bias)
            const mean = SignalAnalysis.mean(output);
            expect(Math.abs(mean)).toBeLessThan(0.05); // Within 5% of zero

            // Should have reasonable variance
            const stdDev = SignalAnalysis.standardDeviation(output);
            expect(stdDev).toBeGreaterThan(0.2); // Noise has spread
            expect(stdDev).toBeLessThan(0.8); // But not too much
        });

        it('should generate sawtooth at correct frequency', () => {
            sources.setDCLevel(0);
            sources.setNoiseLevel(0);
            sources.setToneLevel(1.0);

            const testFrequency = 440;
            const duration = 1.0; // 1 second
            const samples = Math.floor(sampleRate * duration);
            const output = new Float32Array(samples);

            for (let i = 0; i < samples; i++) {
                output[i] = sources.process(testFrequency);
            }

            // Estimate frequency from zero crossings
            const estimatedFreq = SignalAnalysis.estimateFrequency(output, sampleRate);

            // Should be within 1% of target frequency
            expect(estimatedFreq).toBeGreaterThan(testFrequency * 0.99);
            expect(estimatedFreq).toBeLessThan(testFrequency * 1.01);
        });

        it('should not clip when all sources are active', () => {
            sources.setDCLevel(0.5);
            sources.setNoiseLevel(0.3);
            sources.setToneLevel(0.5);

            const output = new Float32Array(1000);
            for (let i = 0; i < output.length; i++) {
                output[i] = sources.process(440);
            }

            // All samples should be valid and within reasonable bounds
            expect(SignalAnalysis.hasValidOutput(output, 10)).toBe(true);

            // Peak shouldn't exceed reasonable limits
            const peak = SignalAnalysis.peakLevel(output);
            expect(peak).toBeLessThan(2.0); // Sum of all sources at max
        });

        it('should maintain sawtooth phase continuity', () => {
            sources.setDCLevel(0);
            sources.setNoiseLevel(0);
            sources.setToneLevel(1.0);

            const output = new Float32Array(1000);
            for (let i = 0; i < output.length; i++) {
                output[i] = sources.process(440);
            }

            // Check for discontinuities (should be smooth sawtooth)
            const discontinuities = SignalAnalysis.detectDiscontinuities(output, 1.5);
            // Sawtooth has one big jump per cycle, but shouldn't have excessive clicks
            expect(discontinuities.count).toBeLessThan(100);
        });

        it('should handle different frequencies correctly', () => {
            sources.setDCLevel(0);
            sources.setNoiseLevel(0);
            sources.setToneLevel(1.0);

            const frequencies = [100, 440, 1000, 5000];

            for (const freq of frequencies) {
                sources.reset();
                const output = new Float32Array(sampleRate); // 1 second

                for (let i = 0; i < output.length; i++) {
                    output[i] = sources.process(freq);
                }

                const estimatedFreq = SignalAnalysis.estimateFrequency(output, sampleRate);
                expect(estimatedFreq).toBeGreaterThan(freq * 0.95);
                expect(estimatedFreq).toBeLessThan(freq * 1.05);
            }
        });
    });
});
</file>

<file path="tests/unit/PMSynthEngine.signal.test.js">
// PMSynthEngine.signal.test.js
// Integration-style checks on engine output using shared signal analysis

import { describe, it, expect } from 'vitest';
import { PMSynthEngine, InterfaceType } from '../../src/audio/PMSynthEngine.js';
import { SignalAnalysis } from '../utils/signal-analyzers.js';

describe('PMSynthEngine signal behaviour', () => {
    const sampleRate = 44100;

    function renderEngineSamples({
        frequency = 220,
        durationSeconds = 0.9,
        noteOffTime = 0.45,
        setup
    } = {}) {
        const engine = new PMSynthEngine(sampleRate);

        // Favour deterministic sources for analysis
        engine.setDCLevel(0.05);
        engine.setNoiseLevel(0.0);
        engine.setToneLevel(1.0);
        engine.setInterfaceType(InterfaceType.PLUCK);
        engine.setInterfaceIntensity(0.6);
        engine.setReverbLevel(0.0);

        if (typeof setup === 'function') {
            setup(engine);
        }

        engine.noteOn(frequency);

        const totalSamples = Math.floor(durationSeconds * sampleRate);
        const buffer = new Float32Array(totalSamples);
        const noteOffSample = Math.floor(noteOffTime * sampleRate);

        for (let i = 0; i < totalSamples; i++) {
            if (i === noteOffSample) {
                engine.noteOff();
            }
            buffer[i] = engine.process();
        }

        return buffer;
    }

    it('produces a stable, non-silent sustain while the note is active', () => {
        const buffer = renderEngineSamples();

        const sustainStart = Math.floor(sampleRate * 0.1);
        const sustainEnd = Math.floor(sampleRate * 0.35);
        const sustainWindow = buffer.subarray(sustainStart, sustainEnd);

        const stats = SignalAnalysis.analyseBuffer(sustainWindow, sampleRate);

        expect(SignalAnalysis.hasValidOutput(sustainWindow, 5)).toBe(true);
        expect(stats.rms).toBeGreaterThan(0.01);
        expect(stats.peak).toBeGreaterThan(0.05);
        expect(Math.abs(stats.dcOffset)).toBeLessThan(0.4);

        const silenceCheck = SignalAnalysis.detectPrematureSilence(sustainWindow, 0.002, 256);
        expect(silenceCheck.premature).toBe(false);
    });

    it('decays in level after note off', () => {
        const buffer = renderEngineSamples();

        const sustainStart = Math.floor(sampleRate * 0.1);
        const sustainEnd = Math.floor(sampleRate * 0.35);
        const releaseStart = Math.floor(sampleRate * 0.5);
        const releaseEnd = Math.floor(sampleRate * 0.65);
        const tailStart = Math.floor(sampleRate * 0.75);
        const tailEnd = Math.floor(sampleRate * 0.9);

        const sustainWindow = buffer.subarray(sustainStart, sustainEnd);
        const releaseWindow = buffer.subarray(releaseStart, releaseEnd);
        const tailWindow = buffer.subarray(tailStart, tailEnd);

        const sustainStats = SignalAnalysis.analyseBuffer(sustainWindow, sampleRate);
        const releaseStats = SignalAnalysis.analyseBuffer(releaseWindow, sampleRate);
        const tailStats = SignalAnalysis.analyseBuffer(tailWindow, sampleRate);

        expect(SignalAnalysis.hasValidOutput(releaseWindow, 5)).toBe(true);
        expect(tailStats.rms).toBeLessThan(0.6);
    });

    const interfaceScenarios = [
        { name: 'pluck', type: InterfaceType.PLUCK, intensity: 0.6 },
        { name: 'hit', type: InterfaceType.HIT, intensity: 0.7 },
        { name: 'reed', type: InterfaceType.REED, intensity: 0.5 }
    ];

    interfaceScenarios.forEach(({ name, type, intensity }) => {
        it(`maintains energy and decays for interface type: ${name}`, () => {
            const buffer = renderEngineSamples({
                setup(engine) {
                    engine.setInterfaceType(type);
                    engine.setInterfaceIntensity(intensity);
                    engine.setNoiseLevel(0.05);
                }
            });

            const sustainStart = Math.floor(sampleRate * 0.12);
            const sustainEnd = Math.floor(sampleRate * 0.32);
            const releaseStart = Math.floor(sampleRate * 0.5);
            const releaseEnd = Math.floor(sampleRate * 0.65);
            const tailStart = Math.floor(sampleRate * 0.75);
            const tailEnd = Math.floor(sampleRate * 0.9);

            const sustainWindow = buffer.subarray(sustainStart, sustainEnd);
            const releaseWindow = buffer.subarray(releaseStart, releaseEnd);
            const tailWindow = buffer.subarray(tailStart, tailEnd);

            const sustainStats = SignalAnalysis.analyseBuffer(sustainWindow, sampleRate);
            const releaseStats = SignalAnalysis.analyseBuffer(releaseWindow, sampleRate);
            const tailStats = SignalAnalysis.analyseBuffer(tailWindow, sampleRate);

            expect(SignalAnalysis.hasValidOutput(sustainWindow, 5)).toBe(true);
            expect(sustainStats.rms).toBeGreaterThan(0.008);
            expect(SignalAnalysis.hasValidOutput(releaseWindow, 5)).toBe(true);
            expect(tailStats.rms).toBeLessThan(0.6);
            expect(Math.abs(sustainStats.dcOffset)).toBeLessThan(0.5);
        });
    });
});
</file>

<file path="tests/utils/signal-analyzers.js">
// signal-analyzers.js
// Signal analysis utilities for validating audio module outputs

import {
    rmsLevel as sharedRmsLevel,
    peakLevel as sharedPeakLevel,
    crestFactor as sharedCrestFactor,
    mean as sharedMean,
    peakToPeak as sharedPeakToPeak,
    computeSpectrum as sharedComputeSpectrum,
    analyseBuffer as sharedAnalyseBuffer
} from '../../src/utils/signalAnalysis.js';

/**
 * Signal analysis functions for systematic output validation
 */
export const SignalAnalysis = {
    /**
     * Detect if signal prematurely drops to silence
     * Useful for catching feedback/envelope issues
     * @param {Float32Array} buffer - Signal to analyze
     * @param {number} threshold - Silence threshold (default 0.001)
     * @param {number} minDuration - Minimum silent samples before flagging (default 100)
     * @param {number} startIndex - Where to start checking (skip attack phase)
     * @returns {{premature: boolean, index: number|null, duration: number}}
     */
    detectPrematureSilence(buffer, threshold = 0.001, minDuration = 100, startIndex = 0) {
        let silentCount = 0;
        let silenceStart = -1;

        for (let i = startIndex; i < buffer.length; i++) {
            if (Math.abs(buffer[i]) < threshold) {
                if (silenceStart === -1) silenceStart = i;
                silentCount++;
                if (silentCount >= minDuration) {
                    return {
                        premature: true,
                        index: silenceStart,
                        duration: silentCount
                    };
                }
            } else {
                silentCount = 0;
                silenceStart = -1;
            }
        }

        return { premature: false, index: null, duration: 0 };
    },

    /**
     * Calculate RMS (Root Mean Square) level
     * Useful for measuring average signal energy
     * @param {Float32Array} buffer - Signal to analyze
     * @param {number} startIndex - Start analysis here
     * @param {number} endIndex - End analysis here (default: buffer.length)
     * @returns {number} RMS level
     */
    rmsLevel(buffer, startIndex = 0, endIndex = buffer.length) {
        return sharedRmsLevel(buffer, startIndex, endIndex);
    },

    /**
     * Calculate peak level (maximum absolute value)
     * @param {Float32Array} buffer - Signal to analyze
     * @returns {number} Peak level
     */
    peakLevel(buffer) {
        return sharedPeakLevel(buffer);
    },

    /**
     * Calculate crest factor (peak / RMS ratio)
     * Useful for detecting clipping or compression
     * @param {Float32Array} buffer - Signal to analyze
     * @returns {number} Crest factor
     */
    crestFactor(buffer) {
        return sharedCrestFactor(buffer);
    },

    peakToPeak(buffer) {
        return sharedPeakToPeak(buffer);
    },

    /**
     * Check if all samples are finite and within reasonable bounds
     * @param {Float32Array} buffer - Signal to analyze
     * @param {number} maxAbsValue - Maximum acceptable absolute value (default 100)
     * @returns {boolean} True if all samples valid
     */
    hasValidOutput(buffer, maxAbsValue = 100) {
        for (let i = 0; i < buffer.length; i++) {
            if (!isFinite(buffer[i]) || Math.abs(buffer[i]) > maxAbsValue) {
                return false;
            }
        }
        return true;
    },

    /**
     * Find all samples that exceed threshold
     * @param {Float32Array} buffer - Signal to analyze
     * @param {number} threshold - Threshold value
     * @returns {{count: number, indices: number[], maxValue: number}}
     */
    findClipping(buffer, threshold) {
        const indices = [];
        let maxValue = 0;

        for (let i = 0; i < buffer.length; i++) {
            const abs = Math.abs(buffer[i]);
            if (abs > threshold) {
                indices.push(i);
                if (abs > maxValue) maxValue = abs;
            }
        }

        return {
            count: indices.length,
            indices: indices,
            maxValue: maxValue
        };
    },

    /**
     * Calculate mean (DC offset)
     * @param {Float32Array} buffer - Signal to analyze
     * @returns {number} Mean value
     */
    mean(buffer) {
        return sharedMean(buffer);
    },

    /**
     * Calculate variance
     * @param {Float32Array} buffer - Signal to analyze
     * @returns {number} Variance
     */
    variance(buffer) {
        const meanVal = this.mean(buffer);
        let sum = 0;
        for (let i = 0; i < buffer.length; i++) {
            const diff = buffer[i] - meanVal;
            sum += diff * diff;
        }
        return sum / buffer.length;
    },

    /**
     * Calculate standard deviation
     * @param {Float32Array} buffer - Signal to analyze
     * @returns {number} Standard deviation
     */
    standardDeviation(buffer) {
        return Math.sqrt(this.variance(buffer));
    },

    /**
     * Count zero crossings (approximate frequency measure)
     * @param {Float32Array} buffer - Signal to analyze
     * @returns {number} Number of zero crossings
     */
    zeroCrossingRate(buffer) {
        let crossings = 0;
        for (let i = 1; i < buffer.length; i++) {
            if ((buffer[i - 1] >= 0 && buffer[i] < 0) ||
                (buffer[i - 1] < 0 && buffer[i] >= 0)) {
                crossings++;
            }
        }
        return crossings;
    },

    /**
     * Estimate fundamental frequency from zero crossings
     * @param {Float32Array} buffer - Signal to analyze
     * @param {number} sampleRate - Sample rate
     * @returns {number} Estimated frequency in Hz
     */
    estimateFrequency(buffer, sampleRate) {
        const crossings = this.zeroCrossingRate(buffer);
        const duration = buffer.length / sampleRate;
        return crossings / (2 * duration); // Divide by 2 (two crossings per cycle)
    },

    /**
     * Measure decay time (time to drop below threshold)
     * Useful for envelope and reverb testing
     * @param {Float32Array} buffer - Signal to analyze
     * @param {number} threshold - Level threshold (default 0.01 = -40dB)
     * @param {number} sampleRate - Sample rate
     * @returns {{samples: number, seconds: number, found: boolean}}
     */
    measureDecayTime(buffer, threshold = 0.01, sampleRate = 44100) {
        // Find peak first
        let peakIndex = 0;
        let peakValue = 0;
        for (let i = 0; i < buffer.length; i++) {
            const abs = Math.abs(buffer[i]);
            if (abs > peakValue) {
                peakValue = abs;
                peakIndex = i;
            }
        }

        // Find where it drops below threshold after peak
        for (let i = peakIndex; i < buffer.length; i++) {
            if (Math.abs(buffer[i]) < threshold) {
                const samples = i - peakIndex;
                return {
                    samples: samples,
                    seconds: samples / sampleRate,
                    found: true
                };
            }
        }

        return {
            samples: buffer.length - peakIndex,
            seconds: (buffer.length - peakIndex) / sampleRate,
            found: false
        };
    },

    /**
     * Check if signal maintains minimum energy level
     * Useful for detecting premature decay in sustaining sounds
     * @param {Float32Array} buffer - Signal to analyze
     * @param {number} minRMS - Minimum acceptable RMS level
     * @param {number} windowSize - Analysis window size (default 100)
     * @returns {{passes: boolean, lowestRMS: number, failIndex: number|null}}
     */
    checkSustainedEnergy(buffer, minRMS, windowSize = 100) {
        let lowestRMS = Infinity;
        let failIndex = null;

        for (let i = 0; i <= buffer.length - windowSize; i += windowSize) {
            const windowRMS = this.rmsLevel(buffer, i, i + windowSize);
            if (windowRMS < lowestRMS) lowestRMS = windowRMS;
            if (windowRMS < minRMS && failIndex === null) {
                failIndex = i;
            }
        }

        return {
            passes: failIndex === null,
            lowestRMS: lowestRMS,
            failIndex: failIndex
        };
    },

    /**
     * Detect discontinuities (clicks/pops)
     * @param {Float32Array} buffer - Signal to analyze
     * @param {number} threshold - Difference threshold (default 0.5)
     * @returns {{count: number, indices: number[], maxDiff: number}}
     */
    detectDiscontinuities(buffer, threshold = 0.5) {
        const indices = [];
        let maxDiff = 0;

        for (let i = 1; i < buffer.length; i++) {
            const diff = Math.abs(buffer[i] - buffer[i - 1]);
            if (diff > threshold) {
                indices.push(i);
                if (diff > maxDiff) maxDiff = diff;
            }
        }

        return {
            count: indices.length,
            indices: indices,
            maxDiff: maxDiff
        };
    },

    /**
     * Check if signal is monotonically increasing/decreasing
     * Useful for envelope attack/release validation
     * @param {Float32Array} buffer - Signal to analyze
     * @param {string} direction - 'increasing' or 'decreasing'
     * @param {number} tolerance - Allow small violations (default 0.0001)
     * @returns {{monotonic: boolean, violations: number}}
     */
    checkMonotonic(buffer, direction = 'increasing', tolerance = 0.0001) {
        let violations = 0;

        for (let i = 1; i < buffer.length; i++) {
            const diff = buffer[i] - buffer[i - 1];
            if (direction === 'increasing' && diff < -tolerance) {
                violations++;
            } else if (direction === 'decreasing' && diff > tolerance) {
                violations++;
            }
        }

        return {
            monotonic: violations === 0,
            violations: violations
        };
    },

    /**
     * Compare two signals and measure similarity
     * @param {Float32Array} signal1 - First signal
     * @param {Float32Array} signal2 - Second signal
     * @returns {{correlation: number, meanSquareError: number}}
     */
    compareSignals(signal1, signal2) {
        const length = Math.min(signal1.length, signal2.length);

        let sum1 = 0, sum2 = 0, sum1Sq = 0, sum2Sq = 0, pSum = 0;
        for (let i = 0; i < length; i++) {
            sum1 += signal1[i];
            sum2 += signal2[i];
            sum1Sq += signal1[i] * signal1[i];
            sum2Sq += signal2[i] * signal2[i];
            pSum += signal1[i] * signal2[i];
        }

        const num = pSum - (sum1 * sum2 / length);
        const den = Math.sqrt((sum1Sq - sum1 * sum1 / length) * (sum2Sq - sum2 * sum2 / length));
        const correlation = den === 0 ? 0 : num / den;

        let mse = 0;
        for (let i = 0; i < length; i++) {
            const diff = signal1[i] - signal2[i];
            mse += diff * diff;
        }
        mse /= length;

        return {
            correlation,
            meanSquareError: mse
        };
    },

    analyseBuffer(buffer, sampleRate, options) {
        return sharedAnalyseBuffer(buffer, sampleRate, options);
    },

    computeSpectrum(buffer, sampleRate) {
        return sharedComputeSpectrum(buffer, sampleRate);
    }
};
</file>

<file path="tests/utils/signal-generators.js">
// signal-generators.js
// Standardized test signal generators for audio module testing

/**
 * Test signal generators for systematic module validation
 */
export const TestSignals = {
    /**
     * Generate an impulse (single spike, rest zeros)
     * Useful for testing transient response and impulse response
     * @param {number} length - Buffer length in samples
     * @param {number} amplitude - Impulse amplitude (default 1.0)
     * @returns {Float32Array}
     */
    impulse(length = 1000, amplitude = 1.0) {
        const buffer = new Float32Array(length);
        buffer[0] = amplitude;
        return buffer;
    },

    /**
     * Generate a step function (DC offset)
     * Useful for testing stability and bias handling
     * @param {number} level - DC level
     * @param {number} length - Buffer length in samples
     * @returns {Float32Array}
     */
    step(level, length = 1000) {
        return new Float32Array(length).fill(level);
    },

    /**
     * Generate a pure sine wave
     * Useful for testing frequency response
     * @param {number} frequency - Frequency in Hz
     * @param {number} sampleRate - Sample rate
     * @param {number} length - Buffer length in samples
     * @param {number} amplitude - Amplitude (default 1.0)
     * @param {number} phase - Initial phase in radians (default 0)
     * @returns {Float32Array}
     */
    sine(frequency, sampleRate, length, amplitude = 1.0, phase = 0) {
        const buffer = new Float32Array(length);
        for (let i = 0; i < length; i++) {
            buffer[i] = amplitude * Math.sin(2 * Math.PI * frequency * i / sampleRate + phase);
        }
        return buffer;
    },

    /**
     * Generate white noise
     * Useful for testing noise handling and stability
     * @param {number} length - Buffer length in samples
     * @param {number} amplitude - Amplitude (default 1.0)
     * @returns {Float32Array}
     */
    whiteNoise(length = 1000, amplitude = 1.0) {
        const buffer = new Float32Array(length);
        for (let i = 0; i < length; i++) {
            buffer[i] = (Math.random() * 2 - 1) * amplitude;
        }
        return buffer;
    },

    /**
     * Generate a square wave
     * Useful for testing nonlinear behavior and discontinuities
     * @param {number} frequency - Frequency in Hz
     * @param {number} sampleRate - Sample rate
     * @param {number} length - Buffer length in samples
     * @param {number} amplitude - Amplitude (default 1.0)
     * @returns {Float32Array}
     */
    square(frequency, sampleRate, length, amplitude = 1.0) {
        const buffer = new Float32Array(length);
        const period = sampleRate / frequency;
        for (let i = 0; i < length; i++) {
            buffer[i] = ((i % period) < (period / 2)) ? amplitude : -amplitude;
        }
        return buffer;
    },

    /**
     * Generate a sawtooth wave
     * Useful for testing aliasing and harmonic content
     * @param {number} frequency - Frequency in Hz
     * @param {number} sampleRate - Sample rate
     * @param {number} length - Buffer length in samples
     * @param {number} amplitude - Amplitude (default 1.0)
     * @returns {Float32Array}
     */
    sawtooth(frequency, sampleRate, length, amplitude = 1.0) {
        const buffer = new Float32Array(length);
        let phase = 0;
        const phaseIncrement = frequency / sampleRate;
        for (let i = 0; i < length; i++) {
            buffer[i] = (phase * 2 - 1) * amplitude;
            phase += phaseIncrement;
            if (phase >= 1.0) phase -= 1.0;
        }
        return buffer;
    },

    /**
     * Generate a tone burst (windowed sine wave)
     * Useful for testing envelope and decay characteristics
     * @param {number} frequency - Frequency in Hz
     * @param {number} sampleRate - Sample rate
     * @param {number} burstLength - Burst duration in samples
     * @param {number} totalLength - Total buffer length
     * @param {number} amplitude - Amplitude (default 1.0)
     * @returns {Float32Array}
     */
    burst(frequency, sampleRate, burstLength, totalLength, amplitude = 1.0) {
        const buffer = new Float32Array(totalLength);
        for (let i = 0; i < Math.min(burstLength, totalLength); i++) {
            // Hann window
            const window = 0.5 * (1 - Math.cos(2 * Math.PI * i / burstLength));
            buffer[i] = window * amplitude * Math.sin(2 * Math.PI * frequency * i / sampleRate);
        }
        return buffer;
    },

    /**
     * Generate a frequency sweep (chirp)
     * Useful for testing filter response across spectrum
     * @param {number} startFreq - Starting frequency in Hz
     * @param {number} endFreq - Ending frequency in Hz
     * @param {number} sampleRate - Sample rate
     * @param {number} length - Buffer length in samples
     * @param {number} amplitude - Amplitude (default 1.0)
     * @returns {Float32Array}
     */
    sweep(startFreq, endFreq, sampleRate, length, amplitude = 1.0) {
        const buffer = new Float32Array(length);
        let phase = 0;
        for (let i = 0; i < length; i++) {
            const t = i / length;
            const freq = startFreq + (endFreq - startFreq) * t;
            buffer[i] = amplitude * Math.sin(phase);
            phase += 2 * Math.PI * freq / sampleRate;
        }
        return buffer;
    },

    /**
     * Generate a ramp (linear increase)
     * Useful for testing parameter ramping
     * @param {number} start - Starting value
     * @param {number} end - Ending value
     * @param {number} length - Buffer length in samples
     * @returns {Float32Array}
     */
    ramp(start, end, length) {
        const buffer = new Float32Array(length);
        const increment = (end - start) / (length - 1);
        for (let i = 0; i < length; i++) {
            buffer[i] = start + increment * i;
        }
        return buffer;
    },

    /**
     * Generate silence (all zeros)
     * Useful as a baseline or for testing reset behavior
     * @param {number} length - Buffer length in samples
     * @returns {Float32Array}
     */
    silence(length = 1000) {
        return new Float32Array(length);
    }
};
</file>

<file path="tests/utils/test-helpers.js">
// test-helpers.js
// Common test patterns and helper functions

import { TestSignals } from './signal-generators.js';
import { SignalAnalysis } from './signal-analyzers.js';

/**
 * Test helper functions for systematic module validation
 */
export const TestHelpers = {
    /**
     * Process a test signal through a module
     * @param {object} module - Module instance with process() method
     * @param {Float32Array} inputSignal - Input signal
     * @param {function} processFunc - Custom process function (module, sample, index) => output
     * @returns {Float32Array} Output signal
     */
    processSignal(module, inputSignal, processFunc = null) {
        const output = new Float32Array(inputSignal.length);

        for (let i = 0; i < inputSignal.length; i++) {
            if (processFunc) {
                output[i] = processFunc(module, inputSignal[i], i);
            } else {
                output[i] = module.process(inputSignal[i]);
            }
        }

        return output;
    },

    /**
     * Test a module with multiple input signals
     * @param {object} module - Module instance
     * @param {Array} testCases - Array of {name, signal, processFunc, validators}
     * @param {object} expect - Vitest expect function
     * @returns {Array} Results for each test case
     */
    runSignalTests(module, testCases, expect) {
        const results = [];

        for (const testCase of testCases) {
            module.reset();

            const output = this.processSignal(
                module,
                testCase.signal,
                testCase.processFunc
            );

            // Run validators
            const validationResults = {};
            for (const [name, validator] of Object.entries(testCase.validators || {})) {
                try {
                    validator(output, expect);
                    validationResults[name] = { passed: true };
                } catch (error) {
                    validationResults[name] = { passed: false, error: error.message };
                }
            }

            results.push({
                name: testCase.name,
                output: output,
                validations: validationResults
            });
        }

        return results;
    },

    /**
     * Sweep a parameter across its full range and validate output
     * @param {object} module - Module instance
     * @param {string} paramName - Parameter setter name (e.g., 'setFrequency')
     * @param {Array} values - Array of parameter values to test
     * @param {Float32Array} inputSignal - Test signal
     * @param {function} processFunc - Custom process function
     * @param {function} validator - Function to validate each output (output, paramValue, expect)
     * @returns {Array} Results for each parameter value
     */
    parameterSweep(module, paramName, values, inputSignal, processFunc, validator) {
        const results = [];

        for (const value of values) {
            module.reset();
            module[paramName](value);

            const output = this.processSignal(module, inputSignal, processFunc);

            const result = {
                paramValue: value,
                output: output,
                valid: true,
                error: null
            };

            try {
                if (validator) {
                    validator(output, value);
                }
            } catch (error) {
                result.valid = false;
                result.error = error.message;
            }

            results.push(result);
        }

        return results;
    },

    /**
     * Stress test: run module for extended duration with random parameter changes
     * @param {object} module - Module instance
     * @param {number} duration - Test duration in samples
     * @param {Array} parameters - Array of {setter, min, max, changeRate}
     * @param {Float32Array} inputSignal - Input signal (will loop if needed)
     * @param {function} processFunc - Custom process function
     * @returns {{output: Float32Array, stable: boolean, issues: Array}}
     */
    stressTest(module, duration, parameters, inputSignal, processFunc = null) {
        module.reset();
        const output = new Float32Array(duration);
        const issues = [];
        let lastParamChange = 0;

        for (let i = 0; i < duration; i++) {
            // Randomly change parameters
            if (parameters && i - lastParamChange > 100) {
                for (const param of parameters) {
                    if (Math.random() < param.changeRate) {
                        const value = param.min + Math.random() * (param.max - param.min);
                        module[param.setter](value);
                        lastParamChange = i;
                    }
                }
            }

            // Process sample
            const inputSample = inputSignal[i % inputSignal.length];
            const outputSample = processFunc
                ? processFunc(module, inputSample, i)
                : module.process(inputSample);

            output[i] = outputSample;

            // Check for issues
            if (!isFinite(outputSample)) {
                issues.push({ index: i, type: 'non-finite', value: outputSample });
            } else if (Math.abs(outputSample) > 100) {
                issues.push({ index: i, type: 'excessive', value: outputSample });
            }
        }

        return {
            output: output,
            stable: issues.length === 0,
            issues: issues
        };
    },

    /**
     * Verify module reset clears all state
     * @param {object} module - Module instance
     * @param {Float32Array} inputSignal - Signal to fill state
     * @param {function} processFunc - Custom process function
     * @param {function} stateChecker - Function to check state (module, expect)
     * @returns {boolean} True if reset successful
     */
    verifyReset(module, inputSignal, processFunc, stateChecker) {
        // Fill module with state
        this.processSignal(module, inputSignal, processFunc);

        // Reset
        module.reset();

        // Check state
        try {
            stateChecker(module);
            return true;
        } catch (error) {
            return false;
        }
    },

    /**
     * Common validators for typical audio module behavior
     */
    validators: {
        /**
         * Validate output stays within bounds
         * @param {number} min - Minimum acceptable value
         * @param {number} max - Maximum acceptable value
         * @returns {function} Validator function
         */
        boundsCheck(min, max) {
            return (output, expect) => {
                const peak = SignalAnalysis.peakLevel(output);
                expect(peak).toBeLessThanOrEqual(max);
                expect(peak).toBeGreaterThanOrEqual(min);
            };
        },

        /**
         * Validate all samples are finite
         * @returns {function} Validator function
         */
        finiteCheck() {
            return (output, expect) => {
                expect(SignalAnalysis.hasValidOutput(output)).toBe(true);
            };
        },

        /**
         * Validate signal doesn't prematurely die
         * @param {number} threshold - Silence threshold
         * @param {number} minDuration - Minimum silent duration before failing
         * @returns {function} Validator function
         */
        noPrematureSilence(threshold = 0.001, minDuration = 100) {
            return (output, expect) => {
                const result = SignalAnalysis.detectPrematureSilence(output, threshold, minDuration);
                expect(result.premature).toBe(false);
            };
        },

        /**
         * Validate minimum energy level is maintained
         * @param {number} minRMS - Minimum RMS level
         * @returns {function} Validator function
         */
        minEnergy(minRMS) {
            return (output, expect) => {
                const rms = SignalAnalysis.rmsLevel(output);
                expect(rms).toBeGreaterThanOrEqual(minRMS);
            };
        },

        /**
         * Validate signal has expected DC offset
         * @param {number} expectedMean - Expected mean value
         * @param {number} tolerance - Acceptable deviation
         * @returns {function} Validator function
         */
        dcOffset(expectedMean, tolerance = 0.01) {
            return (output, expect) => {
                const mean = SignalAnalysis.mean(output);
                expect(mean).toBeCloseTo(expectedMean, -Math.log10(tolerance));
            };
        },

        /**
         * Validate signal has activity (not all zeros)
         * @param {number} minRMS - Minimum RMS to be considered active
         * @returns {function} Validator function
         */
        hasActivity(minRMS = 0.001) {
            return (output, expect) => {
                const rms = SignalAnalysis.rmsLevel(output);
                expect(rms).toBeGreaterThan(minRMS);
            };
        },

        /**
         * Validate no discontinuities (clicks)
         * @param {number} maxDiff - Maximum allowed sample-to-sample difference
         * @returns {function} Validator function
         */
        smooth(maxDiff = 0.5) {
            return (output, expect) => {
                const result = SignalAnalysis.detectDiscontinuities(output, maxDiff);
                expect(result.count).toBe(0);
            };
        }
    },

    /**
     * Create a standard test suite for a module
     * @param {string} moduleName - Module name for describe block
     * @param {function} moduleFactory - Function that returns new module instance
     * @param {object} config - Test configuration
     * @returns {function} Function to call in test file
     */
    createStandardSuite(moduleName, moduleFactory, config) {
        return (describe, it, expect, beforeEach) => {
            describe(`${moduleName} - Signal Processing Tests`, () => {
                let module;

                beforeEach(() => {
                    module = moduleFactory();
                });

                it('should handle impulse response', () => {
                    const input = TestSignals.impulse(1000);
                    const output = this.processSignal(module, input, config.processFunc);
                    expect(SignalAnalysis.hasValidOutput(output)).toBe(true);
                });

                it('should handle DC input', () => {
                    const input = TestSignals.step(0.5, 1000);
                    const output = this.processSignal(module, input, config.processFunc);
                    expect(SignalAnalysis.hasValidOutput(output)).toBe(true);
                });

                it('should handle white noise', () => {
                    const input = TestSignals.whiteNoise(1000);
                    const output = this.processSignal(module, input, config.processFunc);
                    expect(SignalAnalysis.hasValidOutput(output)).toBe(true);
                });

                if (config.additionalTests) {
                    config.additionalTests(module, expect);
                }
            });
        };
    }
};
</file>

<file path="tests/app.spec.js">
import { test, expect } from '@playwright/test';

test.beforeEach(async ({ page }) => {
  await page.goto('http://localhost:5173');
});

test('should have the correct title', async ({ page }) => {
  await expect(page).toHaveTitle('Digital Waveguide Clarinet Synthesizer');
});

test('should turn on the synth when power button is clicked', async ({ page }) => {
  await page.click('#power-button');
  const status = await page.textContent('#status');
  expect(status).toBe('ON');
});

test('should change the note when a key is clicked', async ({ page }) => {
  await page.click('#power-button');
  await page.click('[data-note="C4"]');
  const note = await page.textContent('#current-note');
  expect(note).toBe('C4');
});
</file>

<file path=".gitignore">
# Dependencies
node_modules/

# Build output
dist/

# Logs
*.log
npm-debug.log*

# Environment
.env
.env.local
.env.*.local

# Editor directories
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stove - Physical Modelling Synthesizer</title>
    <link rel="manifest" href="manifest.webmanifest">
    <meta name="theme-color" content="#4a9eff">
    <link rel="apple-touch-icon" href="icon.svg">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .synth-container {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            max-width: 1200px;
            width: 100%;
        }

        .power-button {
            position: absolute;
            left: 0;
            background: linear-gradient(145deg, #444, #222);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            color: #ff4a4a;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .power-button:not(.active) {
            animation: powerPulse 1.6s ease-in-out infinite;
        }

        .power-button:hover {
            color: #ff7373;
        }

        .power-button.active {
            color: #4eff4a;
            box-shadow: 0 0 20px rgba(78, 255, 74, 0.5);
            animation: none;
        }

        .synth-header {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            position: relative;
        }

        .install-button {
            position: absolute;
            right: 0;
            height: 32px;
            padding: 0 14px;
            border-radius: 16px;
            border: none;
            background: linear-gradient(135deg, #ff8a4a, #ff4a8b);
            color: #fff;
            font-size: 11px;
            font-weight: bold;
            letter-spacing: 1px;
            cursor: pointer;
            box-shadow: 0 5px 18px rgba(255, 74, 139, 0.35);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s ease;
            text-transform: uppercase;
        }

        .install-button.visible {
            opacity: 1;
            pointer-events: auto;
            animation: installPulse 1.8s ease-in-out infinite;
        }

        .install-button:hover {
            transform: translateY(-1px) scale(1.02);
        }

        @keyframes installPulse {
            0% {
                box-shadow: 0 4px 14px rgba(255, 74, 139, 0.3);
            }

            50% {
                box-shadow: 0 6px 22px rgba(255, 74, 139, 0.55);
            }

            100% {
                box-shadow: 0 4px 14px rgba(255, 74, 139, 0.3);
            }
        }

        @keyframes powerPulse {
            0% {
                box-shadow: 0 0 6px rgba(255, 74, 74, 0.35);
            }

            50% {
                box-shadow: 0 0 18px rgba(255, 74, 74, 0.75);
            }

            100% {
                box-shadow: 0 0 6px rgba(255, 74, 74, 0.35);
            }
        }

        .synth-header-text {
            text-align: center;
        }

        .synth-title {
            color: #4a9eff;
            font-size: 32px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-bottom: 5px;
        }

        .synth-subtitle {
            color: #888;
            font-size: 12px;
            letter-spacing: 2px;
        }

        .modules-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 15px;
        }

        .control-section {
            background: #333;
            border-radius: 12px;
            padding: 20px;
        }

        .section-title {
            color: #4a9eff;
            font-size: 13px;
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 15px;
            letter-spacing: 1px;
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 20px;
        }

        .control {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .knob-container {
            position: relative;
            width: 60px;
            height: 60px;
            margin-bottom: 8px;
        }

        .knob {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: linear-gradient(145deg, #444, #222);
            box-shadow:
                inset 0 2px 5px rgba(0, 0, 0, 0.5),
                0 2px 10px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            position: relative;
            transition: transform 0.1s;
        }

        .knob::before {
            content: '';
            position: absolute;
            width: 3px;
            height: 20px;
            background: #4a9eff;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 2px;
            box-shadow: 0 0 10px rgba(74, 158, 255, 0.5);
        }

        .knob:hover {
            box-shadow:
                inset 0 2px 5px rgba(0, 0, 0, 0.5),
                0 2px 15px rgba(74, 158, 255, 0.3);
        }

        .switch-container {
            position: relative;
            width: 60px;
            height: 60px;
            margin-bottom: 8px;
        }

        .switch {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: linear-gradient(145deg, #555, #333);
            box-shadow:
                inset 0 2px 5px rgba(0, 0, 0, 0.5),
                0 2px 10px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            position: relative;
            transition: transform 0.1s;
        }

        .switch::before {
            content: '';
            position: absolute;
            width: 4px;
            height: 22px;
            background: #ff9500;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 2px;
            box-shadow: 0 0 10px rgba(255, 149, 0, 0.5);
        }

        .knob-label {
            color: #bbb;
            font-size: 10px;
            text-transform: uppercase;
            text-align: center;
            margin-bottom: 4px;
        }

        .knob-value {
            color: #4a9eff;
            font-size: 10px;
            font-family: monospace;
            font-weight: bold;
        }

        .switch-label {
            color: #ff9500;
            font-size: 10px;
            font-family: monospace;
            font-weight: bold;
            text-align: center;
        }

        .keyboard {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 20px;
            display: flex;
            justify-content: center;
            gap: 2px;
            margin-top: 15px;
            flex-wrap: wrap;
            overflow-x: auto;
        }

        /* Hide second octave on smaller screens */
        @media (max-width: 900px) {
            .key[data-octave="5"] {
                display: none;
            }
        }

        .key {
            width: 50px;
            height: 150px;
            background: white;
            border: 2px solid #333;
            border-radius: 0 0 5px 5px;
            cursor: pointer;
            position: relative;
            transition: all 0.05s;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 10px;
            font-size: 11px;
            color: #999;
        }

        .key:hover {
            background: #f0f0f0;
        }

        .key:active,
        .key.active {
            background: #4a9eff;
            color: white;
            transform: translateY(2px);
        }

        .key.black {
            width: 35px;
            height: 100px;
            background: #222;
            color: #666;
            margin: 0 -18px;
            z-index: 1;
            border: 2px solid #000;
        }

        .key.black:hover {
            background: #333;
        }

        .key.black:active,
        .key.black.active {
            background: #4a9eff;
            color: white;
        }


        .visualizer {
            background: #1a1a1a;
            border-radius: 8px;
            height: 80px;
            margin-bottom: 15px;
            position: relative;
            overflow: hidden;
        }

        .visualizer-canvas {
            width: 100%;
            height: 100%;
        }

        .visualizer-stats {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.45);
            border-radius: 6px;
            padding: 6px 10px;
            display: flex;
            flex-direction: column;
            gap: 2px;
            font-family: monospace;
            font-size: 10px;
            color: #d8e8ff;
            pointer-events: none;
        }

        .visualizer-stats .stat-row {
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }

        .visualizer-stats .stat-label {
            text-transform: uppercase;
            color: #8cbcff;
            letter-spacing: 0.05em;
        }

        .visualizer-stats .stat-value {
            color: #fff;
        }

        /* MIDI Panel Styles */
        .midi-panel {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 15px;
            margin-top: 15px;
        }

        .midi-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            cursor: pointer;
            user-select: none;
        }

        .midi-panel-title {
            color: #ff9500;
            font-size: 13px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .midi-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
        }

        .midi-status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .midi-status-indicator.connected {
            background: #4eff4a;
            box-shadow: 0 0 8px rgba(78, 255, 74, 0.6);
        }

        .midi-status-indicator.disconnected {
            background: #ff4a4a;
            box-shadow: 0 0 8px rgba(255, 74, 74, 0.6);
        }

        .midi-status-indicator.warning {
            background: #ffa500;
            box-shadow: 0 0 8px rgba(255, 165, 0, 0.6);
        }

        .midi-status-text {
            color: #bbb;
            font-size: 10px;
        }

        .midi-activity-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #333;
            transition: background 0.1s;
        }

        .midi-activity-indicator.active {
            background: #4a9eff;
            box-shadow: 0 0 10px rgba(74, 158, 255, 0.8);
        }

        .midi-panel-toggle {
            background: none;
            border: none;
            color: #ff9500;
            font-size: 14px;
            cursor: pointer;
            padding: 4px 8px;
            transition: transform 0.3s;
        }

        .midi-panel-content {
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 1;
        }

        .midi-panel-content.collapsed {
            max-height: 0;
            opacity: 0;
        }

        .midi-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .midi-control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .midi-control-label {
            color: #bbb;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .midi-select {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 6px;
            color: #fff;
            padding: 8px;
            font-size: 11px;
            font-family: inherit;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        .midi-select:hover {
            border-color: #ff9500;
        }

        .midi-select:focus {
            outline: none;
            border-color: #ff9500;
            box-shadow: 0 0 0 2px rgba(255, 149, 0, 0.2);
        }

        .midi-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .midi-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #ff9500;
        }

        .midi-panic-button {
            background: linear-gradient(145deg, #ff4a4a, #cc3838);
            border: none;
            border-radius: 6px;
            color: white;
            padding: 8px 12px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 6px rgba(255, 74, 74, 0.3);
        }

        .midi-panic-button:hover {
            background: linear-gradient(145deg, #ff6a6a, #e04444);
            box-shadow: 0 2px 10px rgba(255, 74, 74, 0.5);
        }

        .midi-panic-button:active {
            transform: translateY(1px);
        }

        @media (max-width: 768px) {
            .synth-container {
                padding: 15px;
            }

            .modules-grid {
                grid-template-columns: 1fr;
            }

            .synth-header {
                flex-direction: column;
                gap: 15px;
            }

            .power-button {
                position: static;
                margin: 0 auto;
            }

            .controls-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 15px;
            }

            .knob-container,
            .switch-container {
                width: 50px;
                height: 50px;
            }

            .midi-controls {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <div class="synth-container">
        <div class="synth-header">
            <button class="power-button" id="power-button">PWR</button>
            <div class="synth-header-text">
                <div class="synth-title">Stove</div>
                <div class="synth-subtitle">Physical Modelling Synthesizer</div>
            </div>
            <button class="install-button" id="install-button" aria-label="Install Stove app">Install</button>
        </div>

        <div class="visualizer">
            <canvas class="visualizer-canvas" id="visualizer"></canvas>
            <div class="visualizer-stats" id="visualizer-stats">
                <div class="stat-row"><span class="stat-label">RMS</span><span class="stat-value"
                        data-stat="rms">0.000</span></div>
                <div class="stat-row"><span class="stat-label">Peak</span><span class="stat-value"
                        data-stat="peak">0.000</span></div>
                <div class="stat-row"><span class="stat-label">P-P</span><span class="stat-value"
                        data-stat="p2p">0.000</span></div>
                <div class="stat-row"><span class="stat-label">Crest</span><span class="stat-value"
                        data-stat="crest">0.00</span></div>
                <div class="stat-row"><span class="stat-label">DC</span><span class="stat-value"
                        data-stat="dc">0.000</span></div>
            </div>
        </div>

        <!-- Row 1: Sources + Envelope -->
        <div class="modules-grid">
            <!-- Sources Section -->
            <div class="control-section">
                <div class="section-title">Sources</div>
                <div class="controls-grid">
                    <div class="control">
                        <div class="knob-label">DC</div>
                        <div class="knob-container">
                            <div class="knob" id="dc-knob"></div>
                        </div>
                        <div class="knob-value" id="dc-value">50</div>
                    </div>
                    <div class="control">
                        <div class="knob-label">Noise</div>
                        <div class="knob-container">
                            <div class="knob" id="noise-knob"></div>
                        </div>
                        <div class="knob-value" id="noise-value">15</div>
                    </div>
                    <div class="control">
                        <div class="knob-label">Tone</div>
                        <div class="knob-container">
                            <div class="knob" id="tone-knob"></div>
                        </div>
                        <div class="knob-value" id="tone-value">0</div>
                    </div>
                </div>
            </div>

            <!-- Envelope Section -->
            <div class="control-section">
                <div class="section-title">Envelope</div>
                <div class="controls-grid">
                    <div class="control">
                        <div class="knob-label">Attack</div>
                        <div class="knob-container">
                            <div class="knob" id="attack-knob"></div>
                        </div>
                        <div class="knob-value" id="attack-value">10</div>
                    </div>
                    <div class="control">
                        <div class="knob-label">Release</div>
                        <div class="knob-container">
                            <div class="knob" id="release-knob"></div>
                        </div>
                        <div class="knob-value" id="release-value">50</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Row 2: Interface + Delay Lines -->
        <div class="modules-grid">
            <!-- Interface Section -->
            <div class="control-section">
                <div class="section-title">Interface</div>
                <div class="controls-grid">
                    <div class="control">
                        <div class="knob-label">Type</div>
                        <div class="switch-container">
                            <div class="switch" id="interface-type-switch"></div>
                        </div>
                        <div class="switch-label" id="interface-type-label">Reed</div>
                    </div>
                    <div class="control">
                        <div class="knob-label">Intensity</div>
                        <div class="knob-container">
                            <div class="knob" id="interface-intensity-knob"></div>
                        </div>
                        <div class="knob-value" id="interface-intensity-value">50</div>
                    </div>
                </div>
            </div>

            <!-- Delay Lines Section -->
            <div class="control-section">
                <div class="section-title">Delay Lines</div>
                <div class="controls-grid">
                    <div class="control">
                        <div class="knob-label">Tuning</div>
                        <div class="knob-container">
                            <div class="knob" id="tuning-knob"></div>
                        </div>
                        <div class="knob-value" id="tuning-value">50</div>
                    </div>
                    <div class="control">
                        <div class="knob-label">Ratio</div>
                        <div class="knob-container">
                            <div class="knob" id="ratio-knob"></div>
                        </div>
                        <div class="knob-value" id="ratio-value">50</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Row 3: Feedback + Filter -->
        <div class="modules-grid">
            <!-- Feedback Section -->
            <div class="control-section">
                <div class="section-title">Feedback</div>
                <div class="controls-grid">
                    <div class="control">
                        <div class="knob-label">Delay 1</div>
                        <div class="knob-container">
                            <div class="knob" id="delay1-fb-knob"></div>
                        </div>
                        <div class="knob-value" id="delay1-fb-value">95</div>
                    </div>
                    <div class="control">
                        <div class="knob-label">Delay 2</div>
                        <div class="knob-container">
                            <div class="knob" id="delay2-fb-knob"></div>
                        </div>
                        <div class="knob-value" id="delay2-fb-value">95</div>
                    </div>
                    <div class="control">
                        <div class="knob-label">Filter</div>
                        <div class="knob-container">
                            <div class="knob" id="filter-fb-knob"></div>
                        </div>
                        <div class="knob-value" id="filter-fb-value">0</div>
                    </div>
                </div>
            </div>

            <!-- Filter Section -->
            <div class="control-section">
                <div class="section-title">Filter</div>
                <div class="controls-grid">
                    <div class="control">
                        <div class="knob-label">Frequency</div>
                        <div class="knob-container">
                            <div class="knob" id="filter-freq-knob"></div>
                        </div>
                        <div class="knob-value" id="filter-freq-value">70</div>
                    </div>
                    <div class="control">
                        <div class="knob-label">Q</div>
                        <div class="knob-container">
                            <div class="knob" id="filter-q-knob"></div>
                        </div>
                        <div class="knob-value" id="filter-q-value">20</div>
                    </div>
                    <div class="control">
                        <div class="knob-label">Shape</div>
                        <div class="knob-container">
                            <div class="knob" id="filter-shape-knob"></div>
                        </div>
                        <div class="knob-value" id="filter-shape-value">0</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Row 4: Modulation + Reverb -->
        <div class="modules-grid">
            <!-- Modulation Section -->
            <div class="control-section">
                <div class="section-title">Modulation</div>
                <div class="controls-grid">
                    <div class="control">
                        <div class="knob-label">LFO Freq</div>
                        <div class="knob-container">
                            <div class="knob" id="lfo-freq-knob"></div>
                        </div>
                        <div class="knob-value" id="lfo-freq-value">30</div>
                    </div>
                    <div class="control">
                        <div class="knob-label">AM/FM</div>
                        <div class="knob-container">
                            <div class="knob" id="mod-type-level-knob"></div>
                        </div>
                        <div class="knob-value" id="mod-type-level-value">0</div>
                    </div>
                </div>
            </div>

            <!-- Reverb Section -->
            <div class="control-section">
                <div class="section-title">Reverb</div>
                <div class="controls-grid">
                    <div class="control">
                        <div class="knob-label">Size</div>
                        <div class="knob-container">
                            <div class="knob" id="reverb-size-knob"></div>
                        </div>
                        <div class="knob-value" id="reverb-size-value">50</div>
                    </div>
                    <div class="control">
                        <div class="knob-label">Level</div>
                        <div class="knob-container">
                            <div class="knob" id="reverb-level-knob"></div>
                        </div>
                        <div class="knob-value" id="reverb-level-value">30</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- MIDI Panel -->
        <div class="midi-panel" id="midi-panel">
            <div class="midi-panel-header" id="midi-panel-toggle">
                <div class="midi-panel-title">
                    <span>MIDI Input</span>
                    <div class="midi-activity-indicator" id="midi-activity-indicator"></div>
                </div>
                <div class="midi-status">
                    <div class="midi-status-indicator disconnected" id="midi-status-indicator"></div>
                    <span class="midi-status-text" id="midi-status-text">Initializing...</span>
                </div>
            </div>

            <div class="midi-panel-content" id="midi-panel-content">
                <div class="midi-controls">
                    <div class="midi-control-group">
                        <label class="midi-control-label" for="midi-device-select">Device</label>
                        <select class="midi-select" id="midi-device-select">
                            <option value="">No device</option>
                        </select>
                    </div>

                    <div class="midi-control-group">
                        <label class="midi-control-label" for="midi-channel-select">Channel</label>
                        <select class="midi-select" id="midi-channel-select">
                            <option value="all">All Channels</option>
                            <option value="1">Channel 1</option>
                            <option value="2">Channel 2</option>
                            <option value="3">Channel 3</option>
                            <option value="4">Channel 4</option>
                            <option value="5">Channel 5</option>
                            <option value="6">Channel 6</option>
                            <option value="7">Channel 7</option>
                            <option value="8">Channel 8</option>
                            <option value="9">Channel 9</option>
                            <option value="10">Channel 10</option>
                            <option value="11">Channel 11</option>
                            <option value="12">Channel 12</option>
                            <option value="13">Channel 13</option>
                            <option value="14">Channel 14</option>
                            <option value="15">Channel 15</option>
                            <option value="16">Channel 16</option>
                        </select>
                    </div>

                    <div class="midi-control-group">
                        <label class="midi-control-label">
                            <div class="midi-toggle">
                                <input type="checkbox" id="midi-enable-toggle" checked>
                                <span>MIDI Enabled</span>
                            </div>
                        </label>
                    </div>

                    <div class="midi-control-group">
                        <label class="midi-control-label" for="midi-panic-button">Emergency</label>
                        <button class="midi-panic-button" id="midi-panic-button">All Notes Off</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Keyboard -->
        <div class="keyboard" id="keyboard">
            <!-- First Octave (C4-B4) -->
            <div class="key white" data-note="C4" data-octave="4">C4</div>
            <div class="key black" data-note="C#4" data-octave="4">C#</div>
            <div class="key white" data-note="D4" data-octave="4">D4</div>
            <div class="key black" data-note="D#4" data-octave="4">D#</div>
            <div class="key white" data-note="E4" data-octave="4">E4</div>
            <div class="key white" data-note="F4" data-octave="4">F4</div>
            <div class="key black" data-note="F#4" data-octave="4">F#</div>
            <div class="key white" data-note="G4" data-octave="4">G4</div>
            <div class="key black" data-note="G#4" data-octave="4">G#</div>
            <div class="key white" data-note="A4" data-octave="4">A4</div>
            <div class="key black" data-note="A#4" data-octave="4">A#</div>
            <div class="key white" data-note="B4" data-octave="4">B4</div>
            <!-- Second Octave (C5-C6) -->
            <div class="key white" data-note="C5" data-octave="5">C5</div>
            <div class="key black" data-note="C#5" data-octave="5">C#</div>
            <div class="key white" data-note="D5" data-octave="5">D5</div>
            <div class="key black" data-note="D#5" data-octave="5">D#</div>
            <div class="key white" data-note="E5" data-octave="5">E5</div>
            <div class="key white" data-note="F5" data-octave="5">F5</div>
            <div class="key black" data-note="F#5" data-octave="5">F#</div>
            <div class="key white" data-note="G5" data-octave="5">G5</div>
            <div class="key black" data-note="G#5" data-octave="5">G#</div>
            <div class="key white" data-note="A5" data-octave="5">A5</div>
            <div class="key black" data-note="A#5" data-octave="5">A#</div>
            <div class="key white" data-note="B5" data-octave="5">B5</div>
            <div class="key white" data-note="C6" data-octave="5">C6</div>
        </div>

    </div>

    <script type="module" src="/src/main.js"></script>
</body>

</html>
</file>

<file path="package.json">
{
  "name": "pm-synth",
  "version": "0.1.0",
  "description": "Physical modelling synthesizer using Web Audio API",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:ui": "vitest --ui",
    "test:e2e": "npx playwright test"
  },
  "devDependencies": {
    "@playwright/test": "^1.56.0",
    "vite": "^7.1.10",
    "vitest": "^3.2.4"
  }
}
</file>

<file path="playwright.config.js">
export default {
  testDir: './tests',
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:5173',
    reuseExistingServer: !process.env.CI,
  },
};
</file>

<file path="README.md">
# Stove - Physical Modelling Synthesizer

A real-time general-purpose physical modeling synthesizer running entirely in the browser using the Web Audio API. Unlike traditional sample-based or subtractive synthesis, Stove recreates the actual physics of sound production, resulting in expressive, organic tones that respond naturally to parameter changes.

## Overview

Stove uses **digital waveguide synthesis** to physically model a wide variety of acoustic instruments:

- **Plucked strings** (guitar, harp, sitar)
- **Struck percussion** (piano, marimba, drums, gongs)
- **Reed instruments** (clarinet, saxophone, oboe)
- **Flute-like instruments** (flute, recorder, pan pipes)
- **Brass instruments** (trumpet, trombone, horn)

The modular architecture allows you to combine different sound sources, interface types, and processing modules to create unique timbres impossible with real instruments.

## Features

### Modular Architecture
- **7 independent modules** with 17 controllable parameters
- **5 interface types** for different instrument behaviors
- **Dual delay lines** with tunable ratio for harmonic/inharmonic sounds
- **Morphable filter** (lowpass â†’ bandpass â†’ highpass)
- **LFO modulation** with bipolar AM/FM control

### Technical
- **AudioWorklet** processing for ultra-low latency (<10ms)
- **Fallback support** with ScriptProcessorNode for older browsers
- **Responsive PWA design** works on desktop, tablet, and mobile
- **Zero latency** parameter changes
- **No sample libraries** - pure algorithmic synthesis

## Quick Start

```bash
cd experiments/pm-synth
npm install
npm run dev
```

Open http://localhost:5173 in your browser and click the PWR button to start.

## How It Works

### Signal Flow

```
Keyboard (Gate + CV)
    â†“
Sources (DC, Noise, Tone) â†’ Envelope (AR) â†’ Interface â†’ Delay Lines â† Feedback
                                                â†“            â†“
                                            Filter â†â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                â†“
                                            Output
                                                â†‘
                                        Modulation (LFO)
```

### Modules

#### 1. **Sources** - Excitation Generation
Three independent signal sources that sum together:
- **DC**: Constant pressure (like wind speed in a blown instrument)
- **Noise**: White noise for breath turbulence
- **Tone**: Sawtooth wave tracking pitch (adds harmonic content)

Each source has independent level control (0-100%).

#### 2. **Envelope** - Amplitude Shaping
Attack-Release envelope applied to the source signal:
- **Attack**: How quickly sound reaches full volume (0.001-0.5s)
- **Release**: How quickly sound fades after note-off (0.01-2.0s)

#### 3. **Interface** - Physical Interaction Model
Eight interaction styles, each morphing with intensity:

- **Pluck**: One-way stick dampening for string picks (0 â†’ soft nylon, 100 â†’ glassy snap)
- **Hit**: Sine-fold shaper for percussive strikes (0 â†’ woody thunk, 100 â†’ metallic crunch)
- **Reed**: Biased saturation like a clarinet reed (0 â†’ mellow, 100 â†’ biting squawk)
- **Flute**: Jet excitation with controllable breath (0 â†’ airy whisper, 100 â†’ hissing edge)
- **Brass**: Asymmetric lip buzz (0 â†’ muted horn, 100 â†’ brassy snarl)
- **Bow**: Stick-slip friction for sustained bows (0 â†’ smooth violin, 100 â†’ scratchy pressure)
- **Bell**: Metallic partial shaper (0 â†’ mellow chime, 100 â†’ shimmery clang)
- **Drum**: Energy-accumulating drive (0 â†’ damped skin, 100 â†’ explosive tom/snare)

#### 4. **Delay Lines** - Resonance
Two parallel delay lines create the resonant body:
- **Tuning**: Coarse pitch adjustment (-12 to +12 semitones)
- **Ratio**: Delay2/Delay1 length ratio
  - < 50: Inharmonic (drum/gong sounds)
  - = 50: Equal length, harmonic (standard)
  - > 50: Stretched harmonics

#### 5. **Feedback** - Energy Return
Three independent feedback paths:
- **Delay 1**: Feedback from first delay line (0-99%)
- **Delay 2**: Feedback from second delay line (0-99%)
- **Filter**: Post-filter feedback (0-99%)

Higher feedback = longer sustain and brighter tone.

#### 6. **Filter** - Tone Shaping
State-variable filter with morphable response:
- **Frequency**: Cutoff/center frequency (20-20000 Hz)
- **Q**: Resonance/bandwidth (0.5-20)
- **Shape**: Filter type morphing
  - 0: Lowpass (warm, muted)
  - 50: Bandpass (nasal, vocal)
  - 100: Highpass (thin, bright)

#### 7. **Modulation** - Movement
LFO with bipolar AM/FM control:
- **LFO Freq**: Modulation rate (0.1-20 Hz)
- **AM/FM**: Bipolar control
  - 0: Maximum amplitude modulation (tremolo)
  - 50: No modulation
  - 100: Maximum frequency modulation (vibrato)

## Controls

### Keyboard
- **Mouse/Touch**: Click or touch the on-screen keys
- **Computer Keyboard**: Play using AWSEDFTGYHUHJK keys
- **Monophonic**: One note at a time (like most wind/string instruments)

### Parameter Ranges

| Module | Parameter | Range | Default |
|--------|-----------|-------|---------|
| **Sources** | DC Level | 0-100 | 50 |
| | Noise Level | 0-100 | 15 |
| | Tone Level | 0-100 | 0 |
| **Envelope** | Attack | 0-100 | 10 |
| | Release | 0-100 | 50 |
| **Interface** | Type | Pluck/Hit/Reed/Flute/Brass/Bow/Bell/Drum | Reed |
| | Intensity | 0-100 | 50 |
| **Delay Lines** | Tuning | 0-100 (Â±12 semitones) | 50 |
| | Ratio | 0-100 (0.5-2.0Ã—) | 50 |
| **Feedback** | Delay 1 | 0-100 | 95 |
| | Delay 2 | 0-100 | 95 |
| | Filter | 0-100 | 0 |
| **Filter** | Frequency | 0-100 (20Hz-20kHz) | 70 |
| | Q | 0-100 (0.5-20) | 20 |
| | Shape | 0-100 (LP-BP-HP) | 0 |
| **Modulation** | LFO Freq | 0-100 (0.1-20Hz) | 30 |
| | AM/FM | 0-100 (AMâ†â†’FM) | 50 |

## Sound Design Tips

### Plucked String (Guitar/Harp)
- Interface: **Pluck**
- Sources: DC 60%, Noise 10%
- Feedback: Delay1 98%, Delay2 98%
- Filter: Lowpass, Freq 80%

### Struck Drum/Gong
- Interface: **Hit**
- Sources: DC 40%, Noise 30%
- Delay Ratio: 30-40 (inharmonic)
- Feedback: Delay1 85%, Delay2 90%

### Clarinet
- Interface: **Reed**
- Sources: DC 50%, Noise 15%
- Feedback: Delay1 95%, Delay2 95%
- Filter: Lowpass, Freq 70%, Q 20%

### Flute
- Interface: **Flute**
- Sources: DC 30%, Noise 25%
- Feedback: Delay1 92%, Delay2 92%
- Filter: Bandpass, Freq 60%, Q 40%

### Trumpet
- Interface: **Brass**
- Sources: DC 60%, Tone 20%
- Feedback: Delay1 93%, Delay2 93%
- Filter: Bandpass, Freq 50%, Q 60%

### Violin Bow
- Interface: **Bow**
- Sources: DC 45%, Noise 10%, Tone 25%
- Feedback: Delay1 96%, Delay2 92%
- Filter: Lowpass, Freq 65%, Q 25%

### Bell Tree
- Interface: **Bell**
- Sources: DC 25%, Noise 20%, Tone 45%
- Ratio: 70%
- Filter: Highpass, Freq 60%, Q 55%
- Reverb: Size 80%, Level 45%

### Drum Head
- Interface: **Drum**
- Sources: DC 35%, Noise 35%, Tone 10%
- Ratio: 35%
- Filter: Bandpass, Freq 45%, Q 30%
- Modulation: AM bias 35%

### Experimental
Try these for unique sounds:
- High **Filter Feedback** with Bandpass (self-oscillation)
- Unequal **Delay Ratios** (metallic, bell-like)
- **Tone Source** + Pluck interface (synthesized string)
- **AM Modulation** + High Q filter (lo-fi radio)

## Technical Details

### Implementation
- **Audio Engine**: Modular DSP architecture (7 independent modules)
- **Processing**: AudioWorklet (44.1 kHz, per-sample processing)
- **Fallback**: ScriptProcessorNode for older browsers
- **Latency**: <10ms with AudioWorklet
- **CPU Usage**: ~5-15% (single core)
- **Memory**: ~2-3 MB

### Browser Compatibility
- âœ… **Chrome/Edge 66+**: Full AudioWorklet support
- âœ… **Firefox 76+**: Full AudioWorklet support
- âœ… **Safari 14.1+**: Full AudioWorklet support
- âš ï¸ **iOS Safari 14.5+**: Requires user interaction for audio

### Architecture

All audio modules follow a consistent API:

```javascript
class ModuleName {
    constructor(sampleRate) { }
    setParameter(name, value) { }  // 0-1 normalized
    process(input, cv, gate) { }    // Returns output
    reset() { }                     // Called on note-on
}
```

**Module Files:**
- `SourcesModule.js` (73 lines)
- `EnvelopeModule.js` (85 lines)
- `InterfaceModule.js` (150 lines)
- `DelayLinesModule.js` (138 lines)
- `FeedbackModule.js` (45 lines)
- `FilterModule.js` (101 lines)
- `ModulationModule.js` (93 lines)

Each module is <200 lines, highly focused, and independently testable.

## Development

### Running Locally
```bash
npm install
npm run dev
```

### Building
```bash
npm run build
```

Output is in the `dist/` directory.

### Testing
```bash
npm test
```

## Project Structure

```
pm-synth/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ audio/
â”‚   â”‚   â”œâ”€â”€ modules/           # 7 DSP modules
â”‚   â”‚   â”œâ”€â”€ PMSynthEngine.js   # Main synthesis engine
â”‚   â”‚   â”œâ”€â”€ pm-synth-worklet.js # AudioWorklet processor
â”‚   â”‚   â””â”€â”€ PMSynthProcessor.js # Web Audio interface
â”‚   â”œâ”€â”€ ui/
â”‚   â”‚   â”œâ”€â”€ KnobController.js      # Rotary knob control
â”‚   â”‚   â”œâ”€â”€ RotarySwitchController.js # 5-position switch
â”‚   â”‚   â”œâ”€â”€ KeyboardController.js  # Musical keyboard
â”‚   â”‚   â””â”€â”€ Visualizer.js          # Waveform display
â”‚   â”œâ”€â”€ main.js               # Application coordinator
â”‚   â””â”€â”€ constants.js          # Default values
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ requirements.md       # Original specification
â”‚   â”œâ”€â”€ PLAN.md              # Implementation plan
â”‚   â””â”€â”€ IMPLEMENTATION_STATUS.md # Development status
â”œâ”€â”€ index.html               # UI layout
â”œâ”€â”€ package.json
â””â”€â”€ README.md               # This file
```

## Theory Background

### Digital Waveguide Synthesis

Invented by Julius O. Smith III at Stanford (CCRMA), digital waveguide synthesis models wave propagation in acoustic systems:

- **Delay lines** represent wave travel time in tubes/strings
- **Filters** simulate energy loss and dispersion
- **Nonlinearities** create harmonic complexity
- **Feedback** maintains oscillation

This technique is:
- âœ… Computationally efficient (real-time on modest hardware)
- âœ… Physically accurate (matches real acoustic behavior)
- âœ… Expressive (parameters behave like real instruments)
- âœ… Compact (no sample libraries required)

### Why Physical Modeling?

Unlike sample-based synthesis:
- **Continuous control**: Every parameter responds in real-time
- **Natural behavior**: Sounds behave like real physics
- **Infinite variety**: No sample library limitations
- **Educational**: Demonstrates acoustic principles

## References

- Smith, J.O. "Physical Modeling Using Digital Waveguides", Computer Music Journal, 1992
- Karjalainen, M. "Plucked-string models: From Karplus-Strong to digital waveguides", Computer Music Journal, 1998
- VÃ¤limÃ¤ki, V. "Discrete-time modeling of acoustic tubes using fractional delay filters", Helsinki University of Technology, 1995
- Cook, P. "Real Sound Synthesis for Interactive Applications", A K Peters, 2002

## Future Enhancements

Potential improvements:
- [ ] Polyphony (multiple simultaneous notes)
- [ ] Preset system with save/load
- [ ] MIDI input support
- [ ] Recording/export to WAV
- [ ] Spectral analysis display
- [ ] Additional interface types (bow, bell, membrane)
- [ ] Stereo processing
- [ ] Reverb module

## License

See parent project for license information.

## Credits

Part of the Flues project - exploring physical modeling synthesis from C to JavaScript.
</file>

<file path="vite.config.js">
import { defineConfig } from 'vite'

export default defineConfig({
  base: './',
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
    rollupOptions: {
      output: {
        manualChunks: undefined,
        // Put worklet files in assets directory like other chunks
        chunkFileNames: 'assets/[name]-[hash].js',
        assetFileNames: 'assets/[name]-[hash][extname]'
      }
    }
  },
  // Ensure worklet files are treated as chunks, not assets
  worker: {
    format: 'es'
  }
})
</file>

<file path="vitest.config.js">
// vitest.config.js
import { defineConfig } from 'vitest/config';

export default defineConfig({
    test: {
        globals: true,
        environment: 'node',
        include: ['tests/unit/**/*.test.js'],
        exclude: ['tests/**/*.spec.js', '**/node_modules/**'],
        coverage: {
            provider: 'v8',
            reporter: ['text', 'json', 'html'],
            include: ['src/**/*.js'],
            exclude: ['src/**/*.test.js', 'src/**/worklet.js']
        }
    }
});
</file>

</files>
